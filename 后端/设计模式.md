# 设计模式介绍

## 简单的介绍

- 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了**最佳的实践**。
- 设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。
- 设计模式并不局限于某种语言，java，php，c++ 都有设计模式。

## 设计模式的类型

1. 创建型：<u>单例模式</u>、抽象工厂模式、原型模式、建造者模式、**工厂模式**

2. 结构型：适配器模式、桥接模式、**装饰模式**、组合模式、外观模式、享

   元模式、**代理模式**

3. 行为型：模版方法模式、命令模式、访问者模式、迭代器模式、<u>观察者</u>

   <u>模式</u>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。



# 单例模式

## 定义

1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法(静态方法)。
2. 单例模式有八种实现方式：(1) 饿汉式(静态常量)(2) 饿汉式（静态代码块）(3) 懒汉式(线程不安全)(4) 懒汉式(线程安全，同步方法)(5) 懒汉式(线程安全，同步代码块)(6) 双重检查(7) 静态内部类(8) 枚举



## 饿汉式(静态常量)

### 步骤

1.构造器私有化 (防止new)

2.类的内部创建对象

3.向外暴露一个静态的公共方法:getInstance

4.代码实现

### 代码部分

```java
public class SingletonTest01 {
	public static void main(String[] args) {
		Singleton instance = Singleton.getInstance();
	}
}
//饿汉式(静态变量)
class Singleton {
	//1. 构造器私有化, 外部能new
	private Singleton() {}
	//2.本类内部创建对象实例
	private final static Singleton instance = new Singleton();
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {return instance;}	
}
```

### 优缺点分析

1.优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。

2.缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成**内存的浪费**。

3.结论：这种单例模式**可用**，**可能**造成内存浪费。

## **饿汉式（静态代码块）**

与静态变量的方式类似，也是在类实例化的过程放在了静态代码块中。

```java
class Singleton {
	//1. 构造器私有化, 外部能new
	private Singleton() {}
	//2.本类内部创建对象实例
	private  static Singleton instance;
	static { // 在静态代码块中，创建单例对象
		instance = new Singleton();
	}
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {return instance;}
	
}
```

有关静态代码块的说明：

- 静态代码块**随着类的加载而执行，而且只执行一次**。
- **静态代码块**：执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁，它仅能初始化类变量，即**static修饰的数据成员**。

## 懒汉式(线程不安全)

注：public static修饰的类的成员方法可以直接通过类名.方法名调用，类方法可在不实例化对象的前提下【直接调用】。

### 代码

```java
class Singleton {
	private static Singleton instance;
	private Singleton() {}
	//提供一个静态的公有方法，当使用到该方法时，才去创建 instance
	//即懒汉式
	public static Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
```

### 优缺点

1.优点：起到了Lazy Loading的效果，但是只能在单线程下使用。

2.缺点：可能会导致多个实例出现的错误情况：如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

### 结论

在实际开发中，**不要使用这种方式**，因为这种方式可能会产生多个实例，违背了单例模式。



## 懒汉式(线程安全，同步方法)

在线程不安全的基础上添加synchronized关键字来控制多线程不安全问题。

### 代码部分

```java
// 懒汉式(线程安全，同步方法)
class Singleton {
	private static Singleton instance;
	private Singleton() {}
	//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
	//即懒汉式
	public static synchronized Singleton getInstance() {
		if(instance == null) {instance = new Singleton();}
		return instance;
	}
}
```

### 优缺点

1.优点：解决了线程不安全问题，并且实现了lazy loading

2.缺点：**<u>效率太低了</u>**，每个线程在想获得类的实例时候，执行getInstance()方法**都要进行同步**。而其实这个方法<u>只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了</u>。**方法进行同步效率太低**。

### 结论

在实际开发中，**不推荐**使用这种方式

## 懒汉式(线程安全，同步代码块)

该模式本质是在上一种模式上进行了改进，因为前面同步方法效率太低，

所以改为同步产生实例化的的代码块

### 代码部分

```java
// 懒汉式(线程安全，同步代码块)
class Singleton {
	private static Singleton instance;
	private Singleton() {}
	//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
	//即懒汉式
	public static Singleton getInstance() {
		if(instance == null) {
            synchronized(Singleton.class){
                instance = new Singleton();
            }
        }
		return instance;
	}
}

```

### 结论

这种方式无法实现线程同步的作用，跟第三种实现方式遇到的情形是一致的，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。

在实际开发中，**不能使用这种方式**。

## 双重检查

**推荐使用**，该方式既可以解决懒加载又可以解决线程安全和效率问题。



### 代码

```java
class Singleton {
	private static volatile Singleton instance;
	private Singleton() {}
	//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
	//同时保证了效率, 推荐使用
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			synchronized (Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 **CPU 总线嗅探机制**告知其他线程该变量副本已经失效，需要重新从主内存中读取。

**volatile 保证了不同线程对共享变量操作的可见性**，也就是说一个线程修改了 volatile 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。

### 总结
1.Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。

2.这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步。

3.线程安全；延迟加载；效率较高

4.结论：在实际开发中，**推荐使用这种单例设计模式**。

## **静态内部类**

推荐使用

### 代码

```java
// 静态内部类完成， 推荐使用
class Singleton {
	private static volatile Singleton instance;
	//构造器私有化
	private Singleton() {}
	//写一个静态内部类,该类中有一个静态属性 Singleton
	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton(); 
	}
	//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
	public static synchronized Singleton getInstance() {return SingletonInstance.INSTANCE;}
}
```

静态内部类在类加载时不会自动调用，只有在类的静态公有方法被调用时才会调用到该静态内部类，且只加载一次，实现了懒加载。

### 总结

1.这种方式采用了类装载的机制来保证初始化实例时只有一个线程。

2.静态内部类方式在Singleton类被装载时**并不会立即实例化**，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。

3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

4.优点：避免了**线程不安全**，利用静态内部类特点实现延迟加载，效率高

5.结论：**推荐使用**

## 枚举

用枚举来实现单例。

注意枚举本身就是一种**特殊的类**。

### 代码

```java
public class SingletonTest08 {
	public static void main(String[] args) {
		Singleton instance = Singleton.INSTANCE;
		instance.sayOK();
	}
}
//使用枚举，可以实现单例, 推荐
enum Singleton {
	INSTANCE; //属性
	public void sayOK() {
		System.out.println("ok~");
	}
}
```

### 总结

1.这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。

2.这种方式是Effective Java作者Josh Bloch 提倡的方式

3.结论：**推荐使用**。

## 单例模式在JDK中的应用

在JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)，因为runtime在java使用过程中一定会用到，所以不会存在内存浪费的现象。

[![QQ20220107222230.png](https://img.pterclub.com/images/2022/01/07/QQ20220107222230.png)](https://s3.pterclub.com:2096/image/v5f31O)

## 注意事项和细节说明

1 单例模式保证了系统内存中该类**只存在一个对象**，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以**提高系统性能**。

2.当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new

3.单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、<u>频繁访问数据库或文件的对象</u>(比如数据源、session工厂等)

# 工厂模式

## 引出

### 场景介绍

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

1.披萨的种类很多(比如 GreekPizz、CheesePizz 等)

2.披萨的制作有 prepare，bake, cut, box 

3.完成披萨店订购功能。



（1）披萨的父类抽象类

```java
//将Pizza 类做成抽象
public abstract class Pizza {
	protected String name; //名字
	//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法
	public abstract void prepare();
	public void bake() {System.out.println(name + " baking;");}
	public void cut() {System.out.println(name + " cutting;");}
	//打包
	public void box() {System.out.println(name + " boxing;");}
	public void setName(String name) {this.name = name;}
}
```

（2）订购披萨类

```java
public class OrderPizza {
	// 构造器
	public OrderPizza() {
		Pizza pizza = null;
		String orderType; // 订购披萨的类型
		do {
			orderType = getType();
			if (orderType.equals("greek")) {
				pizza = new GreekPizza();
				pizza.setName(" 希腊披萨 ");
			} else if (orderType.equals("cheese")) {
				pizza = new CheesePizza();
				pizza.setName(" 奶酪披萨 ");
			} else {
				break;
			}
			//输出pizza 制作过程
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			
		} while (true);
	}
   	private String getType() {//用于获取用户想要的披萨的种类的私有内部类
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}
```

（3）奶酪披萨、希腊披萨等

直接继承父类披萨类即可：

```java
public class CheesePizza extends Pizza {
	@Override
	public void prepare() {
		// TODO Auto-generated method stub
		System.out.println(" 给制作奶酪披萨 准备原材料 ");
	}
}
```

希腊披萨

```java
public class GreekPizza extends Pizza {
	@Override
	public void prepare() {
		// TODO Auto-generated method stub
		System.out.println(" 给希腊披萨 准备原材料 ");
	}
}
```

（4）披萨商店类，相当于一个客户端

```java
//相当于一个客户端，发出订购
public class PizzaStore {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new OrderPizza();
	}
}
```



以上就是使用普通思想进行的编程

### 普通模式的优缺点

1.优点是比较好理解，简单易操作。

2.缺点是违反了设计模式的ocp原则，即**对扩展开放，对修改关闭**。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码。

3.比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做如下修改：

![QQ20220108200938.png](https://img.pterclub.com/images/2022/01/08/QQ20220108200938.png)

## 简单工厂模式

**分析**：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味着，也需要修改，而创建Pizza的代码，**往往有多处**。

**思路：**把**创建Pizza对象封装到一个类中**，这样我们有新的Pizza种类时，只需要修改该类就可，其它有创建到Pizza对象的代码就不需要修改了.-> 简单工厂模式。就是你要任何的披萨类的子类都从工厂里拿，不要私下联系就ok。

### 介绍

1.简单工厂模式是属于创建型模式，是工厂模式的一种。**简单工厂模式**是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中**最简单实用**的模式

2.简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)

3.在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.

### 代码改进

简单工厂模式的**设计方案**: 定义一个可以实例化Pizza对象的类，封装创建对象的代码。

```java
//简单工厂类
public class SimpleFactory {
	//更加orderType 返回对应的Pizza 对象
	//简单工厂模式 也叫 静态工厂模式,这个静态方法就可以直接通过类名.方法名来调用
	public static Pizza createPizza2(String orderType) {
		Pizza pizza = null;
		System.out.println("使用简单工厂模式2");
		if (orderType.equals("greek")) {
			pizza = new GreekPizza();
			pizza.setName(" 希腊披萨 ");
		} else if (orderType.equals("cheese")) {
			pizza = new CheesePizza();
			pizza.setName(" 奶酪披萨 ");
		} else if (orderType.equals("pepper")) {
			pizza = new PepperPizza();
			pizza.setName("胡椒披萨");
		}
		return pizza;
	}
}
```

orederpizza可以改成以下形式：

```java
public class OrderPizza2 {
	Pizza pizza = null;
	String orderType = "";
	// 构造器
	public OrderPizza2() {
		do {
			orderType = getType();
			pizza = SimpleFactory.createPizza2(orderType);//此处使用静态方法直接调用即可
			// 输出pizza
			if (pizza != null) { // 订购成功
				pizza.prepare();
				pizza.bake();
				pizza.cut();
				pizza.box();
			} else {
				System.out.println(" 订购披萨失败 ");
				break;
			}
		} while (true);
	}
	// 写一个方法，可以获取客户希望订购的披萨种类
	private String getType() {
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}
```

在客户端中直接使用new OrderPizza2调用即可。

## **工厂方法模式**

核心思想就是将特殊类的创建延迟到子类初始化时。

场景：披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。 

### 介绍

**工厂方法模式设计方案**：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。

**工厂方法模式**：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将**对象的实例化推迟到子类**。

### 代码

![QQ20220108204247.png](https://img.pterclub.com/images/2022/01/08/QQ20220108204247.png)

重点部分：

OrderPizza类

```java
public abstract class OrderPizza {
	//定义一个抽象方法，createPizza , 让各个工厂子类自己实现
	abstract Pizza createPizza(String orderType);
	// 构造器
	public OrderPizza() {
		Pizza pizza = null;
		String orderType; // 订购披萨的类型
		do {
			orderType = getType();
			pizza = createPizza(orderType); //抽象方法，由工厂子类完成
			//输出pizza 制作过程
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			
		} while (true);
	}
	// 写一个方法，可以获取客户希望订购的披萨种类
	private String getType() {
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}
```

BJOrderPizza类：

```java
public class BJOrderPizza extends OrderPizza {
	@Override
	Pizza createPizza(String orderType) {	
		Pizza pizza = null;
		if(orderType.equals("cheese")) {
			pizza = new BJCheesePizza();
		} else if (orderType.equals("pepper")) {
			pizza = new BJPepperPizza();
		}
		// TODO Auto-generated method stub
		return pizza;
	}
}
```

LDOrderPizza类：

```java
public class LDOrderPizza extends OrderPizza {
	@Override
	Pizza createPizza(String orderType) {
		Pizza pizza = null;
		if(orderType.equals("cheese")) {
			pizza = new LDCheesePizza();
		} else if (orderType.equals("pepper")) {
			pizza = new LDPepperPizza();
		}
		// TODO Auto-generated method stub
		return pizza;
	}
}
```

商店客户端类：

```java
public class PizzaStore {
	public static void main(String[] args) {
		String loc = "bj";//这里做成输入的方式就可以实现按照用户的选择来创建不同口味的披萨
		if (loc.equals("bj")) {
			//创建北京口味的各种Pizza
			new BJOrderPizza();
		} else {
			//创建伦敦口味的各种Pizza
			new LDOrderPizza();
		}
		// TODO Auto-generated method stub
	}
}
```

## 抽象工厂模式

### 基本介绍

1.抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类

2.抽象工厂模式可以将**简单工厂模式**和**工厂方法模式**进行整合。

3.从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。

4.将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了**工厂簇**，更利于代码的维护和扩展。

5.类图：

![QQ20220108211022.png](https://img.pterclub.com/images/2022/01/08/QQ20220108211022.png)

### 代码

1.AbsFactory

```java
//一个抽象工厂模式的抽象层(接口)
public interface AbsFactory {
	//让下面的工厂子类来 具体实现
	public Pizza createPizza(String orderType);
}
```

2.BJFactory

```java
//这是工厂子类
public class BJFactory implements AbsFactory {
	@Override
	public Pizza createPizza(String orderType) {
		Pizza pizza = null;
		if(orderType.equals("cheese")) {
			pizza = new BJCheesePizza();
		} else if (orderType.equals("pepper")){
			pizza = new BJPepperPizza();
		}
		return pizza;
	}
}
```

3.LDFactory

```java
public class LDFactory implements AbsFactory {
	@Override
	public Pizza createPizza(String orderType) {
		Pizza pizza = null;
		if (orderType.equals("cheese")) {
			pizza = new LDCheesePizza();
		} else if (orderType.equals("pepper")) {
			pizza = new LDPepperPizza();
		}
		return pizza;
	}
}
```

4.OrderPizza

```java
public class OrderPizza {
	AbsFactory factory;
	// 构造器
	public OrderPizza(AbsFactory factory) {setFactory(factory);}
	private void setFactory(AbsFactory factory) {
		Pizza pizza = null;
		String orderType = ""; // 用户输入
		this.factory = factory;
		do {
			orderType = getType();
			// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类
			pizza = factory.createPizza(orderType);
			if (pizza != null) { // 订购ok
				pizza.prepare();
				pizza.bake();
				pizza.cut();
				pizza.box();
			} else {
				System.out.println("订购失败");
				break;
			}
		} while (true);
	}
	// 写一个方法，可以获取客户希望订购的披萨种类
	private String getType() {
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}
```

5.PizzaStore

```java
public class PizzaStore {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//new OrderPizza(new BJFactory());
		new OrderPizza(new LDFactory());
	}
}
```

## 工厂模式在JDK-Calendar中的应用

![QQ20220108213353.png](https://img.pterclub.com/images/2022/01/08/QQ20220108213353.png)







![QQ20220108212448.png](https://img.pterclub.com/images/2022/01/08/QQ20220108212448.png)



## 工厂模式小结

1.工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。

2.三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)

3.设计模式的**依赖抽象**原则

- 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，<u>变量不要直接持有具体类的引用</u>。
- 不要让类继承具体类，而是继承抽象类或者是实现interface(接口) 
-  不要覆盖基类中已经实现的方法。

# 原型模式

## 引出

### 场景

现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom羊属性完全相同的10只羊。

传统方法可以直接new十下羊，属性设置一样就可以了。

### 传统方式的优缺点

1.优点是比较好理解，简单易操作。

2.在创建新的对象时，总是需要**重新获取原始对象的属性**，如果创建的对象比较复杂时，效率较低，比如这个类有好几十个属性，那么在复制的时候就非常的麻烦。

3.总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活

### 改进思路

Java中Object类是所有类的根类，Object类提供了一个**clone()**方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个**接口Cloneable**，该接口表示该类能够复制且具有复制的能力 => 原型模式

## 定义

1.原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。

2.原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， **无需知道如何创建的细节**。

3.工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。

## 浅拷贝实现

浅拷贝指的是若拷贝的对象中含有引用类型的成员变量，那么浅拷贝只会进行值传递，将该属性值（引用地址）复制一份给新的对象。浅拷贝使用默认的clone()方法来实现。

### 代码实现

1.羊的本类

```java
public class Sheep implements Cloneable {
	private String name;
	private int age;
	private String color;
	private String address = "蒙古羊";
	public Sheep friend; //是对象, 浅拷贝时只会拷贝引用类型的地址
	public Sheep(String name, int age, String color) {
		super();
		this.name = name;
		this.age = age;
		this.color = color;
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public int getAge() {return age;}
	public void setAge(int age) {this.age = age;}
	public String getColor() {return color;}
	public void setColor(String color) {this.color = color;}
	@Override
	public String toString() {return "Sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";}
    
	//克隆该实例，使用默认的clone方法来完成
	@Override
	protected Object clone()  {
		Sheep sheep = null;
		try {
            sheep = (Sheep)super.clone();
        } catch (Exception e) {
			System.out.println(e.getMessage());
		}
		return sheep;
	}
}
```

2.客户端类

```java
public class Client {
	public static void main(String[] args) {
		Sheep sheep = new Sheep("tom", 1, "白色");
		sheep.friend = new Sheep("jack", 2, "黑色");
		Sheep sheep2 = (Sheep)sheep.clone(); //克隆
		Sheep sheep3 = (Sheep)sheep.clone(); //克隆
		Sheep sheep4 = (Sheep)sheep.clone(); //克隆
		Sheep sheep5 = (Sheep)sheep.clone(); //克隆
		System.out.println("sheep2 =" + sheep2 + "sheep2.friend=" +sheep2.friend.hashCode());
		System.out.println("sheep3 =" + sheep3 + "sheep3.friend=" +sheep3.friend.hashCode());
		System.out.println("sheep4 =" + sheep4 + "sheep4.friend=" +sheep4.friend.hashCode());
		System.out.println("sheep5 =" + sheep5 + "sheep5.friend=" +sheep5.friend.hashCode());
	}
}
```

引用对象的hashcode都是一致的。

### 浅拷贝在spring中的应用

在spring中的beans.xml中将类的scope设置为prototype就是原型模式中的浅拷贝模式。

<bean id="id01" class="com.atguigu.spring.bean.Monster" scope="prototype"/>

### 浅拷贝总结

1.对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。

2.对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（**内存地址**）复制一份给新的对象。因为实际上两个对象的该成员变量都**指向同一个实例**。在这种情况下，<u>在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</u>

## 深拷贝

基本介绍：

1.复制对象的所有**基本数据类型**的成员变量值。

2.为所有引用数据类型的成员变量**申请存储空间**，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，<u>对象进行深拷贝要对整个对象进行拷贝</u>。



实现深拷贝有两种方式：

（1）重写clone方法来实现深拷贝

（2）**通过对象序列化实现深拷贝**(推荐)

### 代码

假设现在我们需要拷贝的对象的类是DeepProtoType，而这个类中成员引用类型的变量是DeepCloneableTarget。

1.DeepCloneableTarget类

```java
public class DeepCloneableTarget implements Serializable, Cloneable {
	private static final long serialVersionUID = 1L;
	private String cloneName;
	private String cloneClass;
	public DeepCloneableTarget(String cloneName, String cloneClass) {
		this.cloneName = cloneName;
		this.cloneClass = cloneClass;
	}
	//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
}
```

2.DeepProtoType类

```java
public class DeepProtoType implements Serializable, Cloneable{
	
	public String name; //String 属性
	public DeepCloneableTarget deepCloneableTarget;// 引用类型
	public DeepProtoType() {
		super();
	}
//方法1和方法2都在这里面，我只不过把具体的代码移到了下方。
}
```

其中深拷贝的**方法1**是用clone方法，这种方法比较繁琐，而且如果有多个引用对象类的话会写多次clone

```java
//深拷贝 - 方式 1 使用clone 方法
	@Override
	protected Object clone() throws CloneNotSupportedException {
		Object deep = null;
		//这里完成对基本数据类型(属性)和String的克隆
		deep = super.clone(); 
		//对引用类型的属性，进行单独处理
		DeepProtoType deepProtoType = (DeepProtoType)deep;
		deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();
		return deepProtoType;
	}
```

**方法2**直接使用序列化的方法，将这个类作为对象序列化流进行读取写入，方便快捷。

```java
//深拷贝 - 方式2 通过对象的序列化实现 (推荐)
	public Object deepClone() {
		//创建流对象
		ByteArrayOutputStream bos = null;
		ObjectOutputStream oos = null;
		ByteArrayInputStream bis = null;
		ObjectInputStream ois = null;
		try {
			//序列化
			bos = new ByteArrayOutputStream();
			oos = new ObjectOutputStream(bos);
			oos.writeObject(this); //当前这个对象以对象流的方式输出
			//反序列化
			bis = new ByteArrayInputStream(bos.toByteArray());
			ois = new ObjectInputStream(bis);
			DeepProtoType copyObj = (DeepProtoType)ois.readObject();
			return copyObj;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		} finally {
			//关闭流
			try {
				bos.close();
				oos.close();
				bis.close();
				ois.close();
			} catch (Exception e2) {
				System.out.println(e2.getMessage());
			}
		}
	}
```

## 原型模式的注意事项与细节

1.创建新的对象比较复杂时，**可以利用原型模式<u>简化</u>对象的创建过程**，同时也能够提高效率。

2.不用重新初始化对象，而是动态地获得对象运行时的状态。

3.如果原始对象**发生变化**(增加或者减少属性)，其它克隆对象的也会发生**相应的变化**，**无需修改**代码。

4.在实现深克隆的时候可能需要比较复杂的代码。

5.原型模式的缺点：

- 需要为每一个类都配置一个 clone 方法
- clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

# 建造者模式

## 引出

先有一个建房子的需求，这个过程为打桩、砌墙、封顶，不过各种房子的过程虽然一样，但是要求不要相同的。

## 传统方式解决问题

### 具体做法

首先写一个房屋的抽象类，让具体的房屋去继承抽象类，之后再由客户端来控制房屋创建的流程。



抽象类AbstractHouse

```Java
public abstract class AbstractHouse {
	//打地基
	public abstract void buildBasic();
	//砌墙
	public abstract void buildWalls();
	//封顶
	public abstract void roofed();
	public void build() {
		buildBasic();
		buildWalls();
		roofed();
	}
}
```

具体类，普通房屋

```java
public class CommonHouse extends AbstractHouse {
	@Override
	public void buildBasic() {System.out.println(" 普通房子打地基 ");}
	@Override
	public void buildWalls() {System.out.println(" 普通房子砌墙 ");}
	@Override
	public void roofed() {System.out.println(" 普通房子封顶 ");}
}
```

客户端类

```java
public class Client {
	public static void main(String[] args) {
		CommonHouse commonHouse = new CommonHouse();
		commonHouse.build();
	}
}
```

### 缺点

在房屋的建造过程具有较多共性时，这样设计过于简单，因为**没有设计缓存层对象**，对程序的拓展和维护不好。换句话说，这种设计方案将产品（即房子）和创建对象的过程（即：建房子的流程）封装在一起了，耦合性增强了。

由此提出**建造者模式**，将产品和产品的建造过程解耦。

## 建造者模式基本介绍

### 基本介绍

1.建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以**将复杂对象的建造过程抽象出来**（<u>抽象类别</u>），使这个抽象过程的<u>不同实现方法</u>可以构造出<u>不同表现</u>（属性）的对象。

2.建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的**类型**和**内容**就可以构建它们，用户**不需要知道内部的具体构建细节**。

### 四个角色

1.Product（产品角色）： 一个**具体**的产品对象。

2.Builder（抽象建造者）： 创建一个Product对象的各个部件指定的**接口**/**抽象类**。

3.ConcreteBuilder（具体建造者）： **实现接口**，构建和装配各个部件。

4.Director（指挥者）： 构建一个**使用Builder接口**的对象。它主要是用于创建一个 复杂的对象。它主要有两个作用，一是：**隔离了客户与对象的生产过程**，二是： **负责控制产品对象的生产过程**。

### 原理类图

![QQ20220128120826.png](https://img.pterclub.com/images/2022/01/28/QQ20220128120826.png)

## 建造者解决盖房需求

假设我们建造房子的流程还是不变，依次为打地基、砌墙、封顶，只不过现在有两种房子需要建造，分别是普通房屋CommonHouse和高楼HighBuilding。下面我们用建造者模式解决该问题：

1.House，是建造出来的产品

```java
public class House {
	private String baise;
	private String wall;
	private String roofed;
	public String getBaise() {return baise;}
	public void setBaise(String baise) {this.baise = baise;}
	public String getWall() {return wall;}
	public void setWall(String wall) {this.wall = wall;}
	public String getRoofed() {return roofed;}
	public void setRoofed(String roofed) {this.roofed = roofed;}
}
```

2.HouseBuilder，抽象的建造者，指定建造产品的流程。

```java
public abstract class HouseBuilder {
	protected House house = new House();
	//将建造的流程写好, 抽象的方法
	public abstract void buildBasic();
	public abstract void buildWalls();
	public abstract void roofed();
	//建造房子好， 将产品(房子) 返回
	public House buildHouse() {return house;}
}
```

3.CommonHouse普通房屋的具体建造者

```java
public class CommonHouse extends HouseBuilder {
	@Override
	public void buildBasic() {System.out.println(" 普通房子打地基5米 ");}
	@Override
	public void buildWalls() {System.out.println(" 普通房子砌墙10cm ");}
	@Override
	public void roofed() {System.out.println(" 普通房子屋顶 ");}
}
```

4.HighBuilding高楼的具体建造者

```java
public class HighBuilding extends HouseBuilder {
	@Override
	public void buildBasic() {System.out.println(" 高楼的打地基100米 ");
	@Override
	public void buildWalls() {System.out.println(" 高楼的砌墙20cm ");}
	@Override
	public void roofed() {System.out.println(" 高楼的透明屋顶 ");}
}
```

5.HouseDirector指挥者

```java
//指挥者，这里去指定制作流程，返回产品
public class HouseDirector {
	HouseBuilder houseBuilder = null;
	//构造器传入 houseBuilder
	public HouseDirector(HouseBuilder houseBuilder) {this.houseBuilder = houseBuilder;}
	//通过setter 传入 houseBuilder
	public void setHouseBuilder(HouseBuilder houseBuilder) {this.houseBuilder = houseBuilder;}
	//如何处理建造房子的流程，交给指挥者
	public House constructHouse() {
		houseBuilder.buildBasic();
		houseBuilder.buildWalls();
		houseBuilder.roofed();
		return houseBuilder.buildHouse();
	}
}
```

6.客户端Client

```java
public class Client {
	public static void main(String[] args) {
		//盖普通房子
		CommonHouse commonHouse = new CommonHouse();
		//准备创建房子的指挥者
		HouseDirector houseDirector = new HouseDirector(commonHouse);
		//完成盖房子，返回产品(普通房子)
		House house = houseDirector.constructHouse();
        
		//若是又要盖高楼
		HighBuilding highBuilding = new HighBuilding();
		//重置建造者
		houseDirector.setHouseBuilder(highBuilding);
		//完成盖房子，返回产品(高楼)
		houseDirector.constructHouse();
	}
}
```



类图

![QQ20220128122140.png](https://img.pterclub.com/images/2022/01/28/QQ20220128122140.png)

## 注意事项和细节

1.客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

2.每一个具体建造者都相对独立，<u>而与其他的具体建造者无关</u>，因此可以很方便地替换具体建造者或增加新的具体建造者， **用户使用不同的具体建造者即可得到不同的产品对象**

3.**可以更加精细地控制产品的创建过程** 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程

4.**增加新的具体建造者无须修改原有类库的代码**，指挥者类针对抽象建造者类编程，系统扩展方便，符合 **“开闭原则**。

5.建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，**如果产品之间的差异性很大，则不适合使用建造者模式**，因此其使用范围受到一定的限制。

6.如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式

7.抽象工厂模式和建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：**具有不同分类维度的产品组合**，采用抽象工厂模式<u>不需要关心构建过程</u>，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

# 适配器模式

## 引出

现实生活中，不同地区的插座可能不同，这个时候如果想跨地区的使用电源则需要适配器。

![QQ20220128155209.png](https://img.pterclub.com/images/2022/01/28/QQ20220128155209.png)

## 基本介绍

1.适配器模式(Adapter Pattern)将某个类的接口**转换**成客户端**期望的另一个接口**表示，主的目的是**兼容性**，让原本因接口不匹配不能一起工作的两个类可以**协同工作**。其别名为包装器(Wrapper)

2.适配器模式属于**结构型模式**。

3.主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。

## 类适配器

### 介绍

基本介绍：Adapter类，通过继承 src类，实现 dst 类接口，完成src->dst的适配。

### 代码实现

加入以生活中的充电器来举例说明，220V交流电相当于src，我们的目标dst是5V直流电

类图如下所示

![QQ20220128155713.png](https://img.pterclub.com/images/2022/01/28/QQ20220128155713.png)

1.Voltage220V被适配的类

```java
public class Voltage220V {
	//输出220V的电压
	public int output220V() {
		int src = 220;
		System.out.println("电压=" + src + "伏");
		return src;
	}
}
```

2.Voltage5V适配接口

```java
public interface IVoltage5V {public int output5V();}
```

3.VoltageAdapter适配器类，注意这里的适配主要是通过**继承**被适配类来实现的

```java
public class VoltageAdapter extends Voltage220V implements IVoltage5V {
	@Override
	public int output5V() {
		//获取到220V电压
		int srcV = output220V();
		int dstV = srcV / 44 ; //转成 5v
		return dstV;
	}
}
```

4.Phone手机类

```java
public class Phone {
	public void charging(IVoltage5V iVoltage5V) {
		if(iVoltage5V.output5V() == 5) {
			System.out.println("电压为5V, 可以充电~~");
		} else if (iVoltage5V.output5V() > 5) {
			System.out.println("电压大于5V, 不能充电~~");
		}
	}
}
```

5.Clinet客户端类

```java
public class Client {
	public static void main(String[] args) {
		System.out.println(" === 类适配器模式 ====");
		Phone phone = new Phone();
		phone.charging(new VoltageAdapter());
	}
}
```

### 注意事项和细节

1.Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为**这要求dst必须是接口，有一定局限性**;

2.src类的方法在Adapter中都会暴露出来，也**增加了使用的成本**。

3.由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的**灵活性增强**了。

## 对象适配器模式（常用）

1.基本思路和类的适配器模式相同，只是将Adapter类作修改，<u>不是继承src类</u>，而是**持有**src类的实例，以解决兼容性的问题。

2.根据“合成复用原则”，在系统中尽量**使用关联关系来替代继承关系**。

### 代码

体现在代码层面最关键的一个就是不继承而是持有src类的示例，用关联代替继承。

![QQ20220128160551.png](https://img.pterclub.com/images/2022/01/28/QQ20220128160551.png)

最关键的就是VoltageAdapter类的改变：

```java
public class VoltageAdapter implements IVoltage5V {
    private Voltage220V voltage220V;//关联关系-聚合
    //通过构造器，传入一个Voltage220V实例
    public VoltageAdapter(Voltage220V voltage220v){
        this.voltage220v=voltage220v;
    }
	@Override
	public int output5V() {
		int dst=0;
        if(null!=voltage220V){
            int src=voltage220V.output220V();
            dst = src/44;
        }
        return dst;
	}
}
```

然后Client类需要做下微调，需要实例化被适配器类的对象以供构造器初始化：

```java
public class Client {
	public static void main(String[] args) {
		Phone phone = new Phone();
		phone.charging(new VoltageAdapter(new Voltage220V()));
	}
}
```

### 注意事项

1.对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它**解决了类适配器必须继承src的局限性问题**，也**不再要求dst必须是接口**。

2.使用成本更低，更灵活。

## 接口适配器

非常简单，用一个抽象类类实现接口，抽象类里对每个方法都提供默认实现（空方法），那么那么该抽象类的子类可**有选择**地**覆盖父类的某些方法**来<u>实现需求</u>。

1.一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。

2.当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。

3.适用于一个接口**不想使用其所有的方法**的情况。

# 桥接模式

## 问题引出

如果我们需要对不同版型的手机的不同品牌实现操作编程，需要模拟出手机的各个功能（比如：开机、关机、上网、打电话等），如下图所示：

![QQ截图20220209135228.png](https://s2.loli.net/2022/02/09/pMR93LJafiok756.png)

如果像上图一样用传统的方式，每个版型下面都有各自的品牌，则如下图所示：

![QQ截图20220209135259.png](https://s2.loli.net/2022/02/09/6aMgLqoXmvWFwb1.png)

首先是一个大的手机父类，然后由具体的版型继承手机父类，再然后使用品牌来继承具体的版型类从而实现确定一个手机的版型与品牌，但是这样不利于增加手机的版型或者品牌，即造成扩展性问题。

总结下来，传统方式有如下缺点：

1.扩展性问题(类爆炸)，如果我们**再增加**手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，**也要在各个手机样式类下增加**。

2.违反了单一职责原则，**当我们增加手机样式时，要同时增加所有品牌的手机**，这样增加了代码维护成本.

## 问题的解决

### 桥接模式基本介绍

1.桥接模式(Bridge模式)是指：将**实现**与**抽象**放在两个不同的类层次中，使两个层次可以**独立改变**。

2.是一种结构型设计模式。

3.Bridge模式基于**类的最小设计原则**，通过使用**封装**、**聚合**及**继承**等行为让不同的类承担不同的职责。它的主要特点是把**抽象**(Abstraction)与**行为实现**(Implementation)分离开来，从而可以**保持各部分的独立**性以及**应对他们的功能扩展**。

![QQ截图20220209141200.png](https://s2.loli.net/2022/02/09/zh17ueVSfY592mJ.png)

### 代码

#### UML类图

![QQ截图20220209141530.png](https://s2.loli.net/2022/02/09/fLuxqp5eUEgVMI7.png)

#### 各个类

1.Brand接口

```java
public interface Brand {
	void open();
	void close();
	void call();
}
```

2.Vivo和XiaoMi类实现接口。

```java
public class Vivo implements Brand {
	@Override
	public void open() {System.out.println(" Vivo手机开机 ");}
	@Override
	public void close() {System.out.println(" Vivo手机关机 ");}
	@Override
	public void call() {System.out.println(" Vivo手机打电话 ");}
}
```

```java
public class XiaoMi implements Brand {
	@Override
	public void open() {System.out.println(" 小米手机开机 ");}
	@Override
	public void close() {System.out.println(" 小米手机关机 ");}
	@Override
	public void call() {System.out.println(" 小米手机打电话 ");}
}
```

3.Phone抽象类

```java
public abstract class Phone {
	//组合品牌
	private Brand brand;
	//构造器
	public Phone(Brand brand) {
		super();
		this.brand = brand;
	}
	protected void open() {this.brand.open();}
	protected void close() {this.brand.close();}
	protected void call() {this.brand.call();}
}
```

4.FoldedPhone具体类

```java
//折叠式手机类，继承 抽象类 Phone
public class FoldedPhone extends Phone {
	//构造器
	public FoldedPhone(Brand brand) {super(brand);}
	public void open() {
		super.open();
		System.out.println(" 折叠样式手机 ");
	}
	public void close() {
		super.close();
		System.out.println(" 折叠样式手机 ");
	}
	public void call() {
		super.call();
		System.out.println(" 折叠样式手机 ");
	}
}
```

5.Client客户端类

```java
public class Client {
	public static void main(String[] args) {
		//获取折叠式手机 (样式(折叠) + 品牌（小米） )
		Phone phone1 = new FoldedPhone(new XiaoMi());
		phone1.open();
		phone1.call();
		phone1.close();
		System.out.println("=======================");
		Phone phone2 = new FoldedPhone(new Vivo());//（Vivo牌的折叠手机）
		phone2.open();
		phone2.call();
		phone2.close();
		System.out.println("==============");
	}
}
```

这个时候如果想添加一个直立式版型，则非常方便，直接继承Phone即可

6.UpRightPhone

```java
public class UpRightPhone extends Phone {
		//构造器
		public UpRightPhone(Brand brand) {super(brand);}
		public void open() {
			super.open();
			System.out.println(" 直立样式手机 ");
		}
		public void close() {
			super.close();
			System.out.println(" 直立样式手机 ");
		}
		public void call() {
			super.call();
			System.out.println(" 直立样式手机 ");
		}
}
```

## 桥接模式在JDBC源码中的使用

主要使用在：

1.Jdbc 的 Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的Driver，这些就可以当做实现接口类

## 注意事项和细节

1.实现了**抽象**和**实现部分**的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行**分层设计**，从而产生更好的结构化系统。

2.对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。

3.桥接模式**替代**<u>多层继承方案</u>，可以减少子类的个数，降低系统的管理和维护成本。

4.桥接模式的引入**增加了系统的理解和设计难度**，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。

5.桥接模式要求**正确识别**出系统中**两个独立变化的维度**（在本例子中，两个独立变化的维度就是手机的版型和各个品牌），因此其使用范围有**一定的局限性**，即需要有这样的应用场景。

## 桥接模式的其他应用场景

1.对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.

2.常见的应用场景：

![QQ截图20220209143103.png](https://s2.loli.net/2022/02/09/VgAoTwLv5jJz3pc.png)

# 装饰者设计模式

## 问题引出

现在考虑星巴克咖啡（咖啡馆）订单项目：

1.咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)

2.调料：Milk、Soy(豆浆)、Chocolate

3.要求在扩展**新的咖啡种类**时，具有良好的扩展性、改动方便、维护方便。

4.使用OOP（面向对象的思想）的来计算不同种类咖啡的**费用** ：客户可以点**单品咖啡**，也可以**单品咖啡**+**调料**组合。

### 较差的方案1

把每个组合类都列举出来，这种方法的弊端显而易见，一是组合数量十分庞大，二是当调料可以加多份时，组合数是无穷不可计算的。

#### 示意图

![QQ20220209155313.png](https://img.pterclub.com/images/2022/02/09/QQ20220209155313.png)

#### 分析

![QQ20220209155507.png](https://img.pterclub.com/images/2022/02/09/QQ20220209155507.png)

### 较好的方案二

前面分析到方案1因为咖啡单品+调料组合会造成**类的倍增**，因此可以做改进，将调料**内置到Drink类**，这样就不会造成类数量过多。从而提高项目的维护性(如图)

#### 示意图

![QQ20220209155641.png](https://img.pterclub.com/images/2022/02/09/QQ20220209155641.png)

#### 分析

1.方案2可以控制类的数量，不至于造成很多的类

2.在**增加或者删除调料种类**时，代码的维护量很大（弊端）

## 定义

1.装饰者模式：**动态的**将新功能**附加到对象上**。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)。而且可以通过递归的方式添加任意个装饰物。

原先我们的思想是把调料倒进咖啡里，现在这个装饰者模式的思想更倾向于将咖啡导入装饰物中，比如将Decaf导进chocolate中，再将Decf+chocolate导入soy(豆浆)中从而形成Decaf+chocolate+soy的组合。

2.原理

（1）装饰者模式就像**打包一个快递**

​		主体：比如：陶瓷、衣服 (Component) // 被装饰者

​		包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)

（2）Component。主体：比如类似前面的Drink

（3）ConcreteComponent和Decorator

​		ConcreteComponent：具体的主体，比如前面的各个单品咖啡。

​		Decorator: 装饰者，比如各调料。

![QQ20220209160337.png](https://img.pterclub.com/images/2022/02/09/QQ20220209160337.png)

## 使用装饰者模式解决星巴克咖啡问题

### 示意图

![QQ20220209160514.png](https://img.pterclub.com/images/2022/02/09/QQ20220209160514.png)

假设我们想要在装饰者模式下点一份订单，订单是：2份巧克力+1份牛奶的LongBlack

![QQ20220209161003.png](https://img.pterclub.com/images/2022/02/09/QQ20220209161003.png)

### 代码

1.ShortBlack、Decaf、Espresso和LongBlack是四种单品咖啡种类

(1)ShortBlack

```java
public class ShortBlack extends Coffee{
	public ShortBlack() {
		setDes(" shortblack ");
		setPrice(4.0f);
	}
}
```

(2)Decaf

```java
public class DeCaf extends Coffee {
	public DeCaf() {
		setDes(" 无因咖啡 ");
		setPrice(1.0f);
	}
}
```

(3)Espresso

```java
public class Espresso extends Coffee {
	public Espresso() {
		setDes(" 意大利咖啡 ");
		setPrice(6.0f);
	}
}
```

(4)LongBlack

```java
public class LongBlack extends Coffee {
	public LongBlack() {
		setDes(" longblack ");
		setPrice(5.0f);
	}
}
```

2.这四种咖啡可以提取共性后形成一个缓冲层类**Coffee**

```java
public class Coffee  extends Drink {
	@Override
	public float cost() {
		// TODO Auto-generated method stub
		return super.getPrice();
	}
}
```

3.而Coffee类是缓冲层，在具体类（比如LongBlack）和最抽象的饮品类（抽象**Drink**）之间做一个缓冲。

```java
public abstract class Drink {
	public String des; // 描述
	private float price = 0.0f;//价格
	public String getDes() {return des;}
	public void setDes(String des) {this.des = des;}
	public float getPrice() {return price;}
	public void setPrice(float price) {this.price = price;}
	//计算费用的抽象方法
	//子类来实现
	public abstract float cost();
}
```

4.Decorator类是所有调料的父类，而Decorator类也是Drink的子类。

```java
public class Decorator extends Drink {
	private Drink obj;//组合
	public Decorator(Drink obj) { this.obj = obj;}
	@Override
	public float cost() {
		return super.getPrice() + obj.cost();// getPrice 自己的价格，加上组合物的价格
	}
	@Override
	public String getDes() {
		// obj.getDes() 输出被装饰者的信息
		return des + " " + getPrice() + " && " + obj.getDes();
	}
}
```

5.Chocolate、Milk和Soy类都是调料品类

(1)Chocolate

```java
//具体的Decorator， 这里就是调味品
public class Chocolate extends Decorator {
	public Chocolate(Drink obj) {
		super(obj);
		setDes(" 巧克力 ");
		setPrice(3.0f); // 调味品 的价格
	}
}
```

(2)Milk

```java
public class Milk extends Decorator {
	public Milk(Drink obj) {
		super(obj);
		setDes(" 牛奶 ");
		setPrice(2.0f); 
	}
}
```

(3)Soy

```java
public class Soy extends Decorator{
	public Soy(Drink obj) {
		super(obj);
		setDes(" 豆浆  ");
		setPrice(1.5f);
	}
}
```

6.客户端CoffeeBar类

```java
public class CoffeeBar {
	public static void main(String[] args) {
		// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack
		// 1. 点一份 LongBlack
		Drink order = new LongBlack();
		System.out.println("费用1=" + order.cost());
		System.out.println("描述=" + order.getDes());
		// 2. order 加入一份牛奶
		order = new Milk(order);//将第一个order传入milk中再赋值给自己，最后计算的时候使用递归的方式得到总价
		System.out.println("order 加入一份牛奶 费用 =" + order.cost());
		System.out.println("order 加入一份牛奶 描述 = " + order.getDes());
		// 3. order 加入一份巧克力
		order = new Chocolate(order);
		System.out.println("order 加入一份牛奶 加入一份巧克力  费用 =" + order.cost());
		System.out.println("order 加入一份牛奶 加入一份巧克力 描述 = " + order.getDes());
		// 3. order 加入一份巧克力
		order = new Chocolate(order);
		System.out.println("order 加入一份牛奶 加入2份巧克力   费用 =" + order.cost());
		System.out.println("order 加入一份牛奶 加入2份巧克力 描述 = " + order.getDes());
		System.out.println("===========================");
        
		Drink order2 = new DeCaf();
		System.out.println("order2 无因咖啡  费用 =" + order2.cost());
		System.out.println("order2 无因咖啡 描述 = " + order2.getDes());
		
		order2 = new Milk(order2);
		System.out.println("order2 无因咖啡 加入一份牛奶  费用 =" + order2.cost());
		System.out.println("order2 无因咖啡 加入一份牛奶 描述 = " + order2.getDes());
	}
}
```

输出如下：

![QQ20220209162636.png](https://img.pterclub.com/images/2022/02/09/QQ20220209162636.png)

## 装饰者模式在JDK中主要应用在FilterInputStream

![QQ20220209162813.png](https://img.pterclub.com/images/2022/02/09/QQ20220209162813.png)

# 组合模式

## 问题引出

编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图：

![QQ20220210161317.png](https://img.pterclub.com/images/2022/02/10/QQ20220210161317.png)

### 传统方式

如果我们用传统方式，将学院堪称学校的子类，各个系堪称学院的子类的话，这样就不能很好实现**管理**的功能，比如对学院、系的增加，删除，遍历等等。

### 使用组合模式

把学校、院、系**都看做**是**组织结构**，他们之间**没有继承**的关系，而是一个树形结构，可以更好的实现管理操作。 => 组合模式

## 定义

1.组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的**树形结构**，将对象组合成树状结构以表示“**整体-部分**”的层次关系。

2.组合模式依据树形结构来组合对象，用来表示部分以及整体层次。

3.这种类型的设计模式属于结构型模式。

4.组合模式使得用户对单个对象和组合对象的访问具有**一致性**，**即**：组合能让客户以一致的方式处理个别对象以及组合对象。

## 原理类图

![QQ20220210161728.png](https://img.pterclub.com/images/2022/02/10/QQ20220210161728.png)

各个角色的定义和作用：

![QQ20220210161900.png](https://img.pterclub.com/images/2022/02/10/QQ20220210161900.png)

## 代码

### 类图

![QQ20220210162005.png](https://img.pterclub.com/images/2022/02/10/QQ20220210162005.png)

### 具体类

1.OrganizationComponent作为Component

```java
public abstract class OrganizationComponent {
	private String name; // 名字
	private String des; // 说明
	protected  void add(OrganizationComponent organizationComponent) {
		//默认实现
		throw new UnsupportedOperationException();
	}
	
	protected  void remove(OrganizationComponent organizationComponent) {
		//默认实现
		throw new UnsupportedOperationException();
	}
	//构造器
	public OrganizationComponent(String name, String des) {
		super();
		this.name = name;
		this.des = des;
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public String getDes() {return des;}
	public void setDes(String des) {this.des = des;}
	//方法print, 做成抽象的, 子类都需要实现
	protected abstract void print();
}
```

2.University、College和Department都继承自OrganizationComponent，他们之间互相的关系是平行同类的，但是我们逻辑上应该把他们看成一个包含的关系。不过在代码层面上，**理论上来说University可以直接包含Department，反之亦然**，这也是组合模式的一个缺点，在新增加构件时可能会出现一些问题。

(1)University类

```java
//University 就是 Composite , 可以管理College
public class University extends OrganizationComponent {
	List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();
	// 构造器
	public University(String name, String des) {super(name, des);}
	// 重写add
	@Override
	protected void add(OrganizationComponent organizationComponent) {
		organizationComponents.add(organizationComponent);
	}
	// 重写remove
	@Override
	protected void remove(OrganizationComponent organizationComponent) {
		organizationComponents.remove(organizationComponent);
	}
	@Override
	public String getName() {return super.getName();}
	@Override
	public String getDes() {return super.getDes();}
	// print方法，就是输出University 包含的学院
	@Override
	protected void print() {
		// TODO Auto-generated method stub
		System.out.println("--------------" + getName() + "--------------");
		//遍历 organizationComponents 
		for (OrganizationComponent organizationComponent : organizationComponents) {
			organizationComponent.print();
		}
	}
}
```

（2）College类

```java
public class College extends OrganizationComponent {
	//List 中 存放的Department
	List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();
	// 构造器
	public College(String name, String des) {super(name, des);}
	// 重写add
	@Override
	protected void add(OrganizationComponent organizationComponent) {
		// 这里的话add逻辑与University一致，但是将来实际业务中，Colleage 的 add 和  University add不一定完全一样
		organizationComponents.add(organizationComponent);
	}
	// 重写remove
	@Override
	protected void remove(OrganizationComponent organizationComponent) {
		organizationComponents.remove(organizationComponent);
	}
	@Override
	public String getName() {return super.getName();}
	@Override
	public String getDes() {return super.getDes();}
	// print方法，就是输出University 包含的学院
	@Override
	protected void print() {
		System.out.println("--------------" + getName() + "--------------");
		//遍历 organizationComponents 
		for (OrganizationComponent organizationComponent : organizationComponents) {
			organizationComponent.print();
		}
	}
}
```

（3）Department类作为叶子结点，无需实现add和remove抽象方法。

```java
public class Department extends OrganizationComponent {
	//没有集合
	public Department(String name, String des) {super(name, des);}
	//add , remove 就不用写了，因为他是叶子节点
	@Override
	public String getName() {return super.getName();}
	@Override
	public String getDes() {return super.getDes();}
	@Override
	protected void print() {System.out.println(getName());}
}
```

## 在JDK中的应用

主要体现在HashMap中

![QQ20220210163625.png](https://img.pterclub.com/images/2022/02/10/QQ20220210163625.png)

对应的类图

![QQ20220210163706.png](https://img.pterclub.com/images/2022/02/10/QQ20220210163706.png)

## 注意事项

### 组合模式适合解决的问题

1.组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用**考虑它是节点还是叶子**。即节点和叶子差异并不是很大的时候。如下图所示

![QQ20220210163436.png](https://img.pterclub.com/images/2022/02/10/QQ20220210163436.png)

### 细节

1.组合模式**简化**了客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。

2.具有较强的**扩展性**。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动

3.方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。

4.需要遍历组织结构，或者处理的对象具有树形结构时, 非常适合使用组合模式。

5.要求较高的<u>抽象性</u>，**如果节点和叶子有很多差异性的话**，比如很多方法和属性都不一样，不适合使用组合模式。

# 外观模式

## 问题引出

现有一个组建家庭影院的功能，要求统筹调用各个部件，具体如下

![QQ20220211160029.png](https://img.pterclub.com/images/2022/02/11/QQ20220211160029.png)

### 传统方式

#### 传统的思想做法

若用传统思考方式来解决的话，会直接在ClientTest类中调用各个部件类里的方法，在代码层面看上去就会比较混乱，如下图所示：

![QQ20220211160216.png](https://img.pterclub.com/images/2022/02/11/QQ20220211160216.png)

#### 传统方式分析

1.在ClientTest 的main方法中，创建各个子系统的对象，并直接去调用子系统(对象) 相关方法，会造成调用过程混乱，没有清晰的过程。

2.不利于在ClientTest 中，去维护对子系统的操作

3.解决思路：定义一个**高层接口**，给子系统中的一组接口提供一个**一致的界面**(比如在高层接口提供四个方法 ready, play, pause, end )，用来访问子系统中的 一群接口。

4.也就是说就是通过定义一个**一致的接口**(<u>界面类</u>)，用以屏蔽内部子系统的细节， 使得调用端**只需**跟这个接口发生调用，而**无需关心**这个子系统的**内部细节** => 外观模式

## 外观模式的定义

### 基本介绍

1.外观模式（Facade），也叫“<u>过程模式</u>：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

2.外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。

### 原理类图

![QQ20220211160611.png](https://img.pterclub.com/images/2022/02/11/QQ20220211160611.png)

说明：

1.外观类(Facade): 为调用端提供**统一**的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当 子系统对象

2.调用者(Client): 外观接口的调用者

3.子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者

## 外观模式解决影院管理问题

### 思路

1.外观模式可以理解为**转换**一群接口，**客户只要调用一个接口**，而不用调用多个接口才能达到目的。比如：在pc上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。

2.外观模式就是解决多个复杂接口带来的使用困难，起到**简化**用户操作的作用。

### 示意图

![QQ20220211160821.png](https://img.pterclub.com/images/2022/02/11/QQ20220211160821.png)

### 代码

下面各个子系统因为在整个程序的生命周期里只有一个，所以考虑使用单例模式，这里的单例模式使用最为 推荐的枚举型单例模式。

1.各个子部件系统：

（1）DVDPlayer

```java
public enum DVDPlayer {
    Instance;
    public void on() {System.out.println(" dvd on ");}
    public void off() {System.out.println(" dvd off ");}
    public void play() {System.out.println(" dvd is playing ");}
    public void pause() {System.out.println(" dvd pause ..");}
}
```

(2)Popcorn

```java
public enum Popcorn {
    Instance;
    public void on() {System.out.println(" popcorn on ");}
    public void off() {System.out.println(" popcorn ff ");}
    public void pop() {System.out.println(" popcorn is poping  ");}
}
```

(3)Projector

```java
public enum Projector {
    Instance;
    public void on() {System.out.println(" Projector on ");}
    public void off() {System.out.println(" Projector ff ");}
    public void focus() {System.out.println(" Projector is Projector  ");}
}
```

(4)Screen

```java
public enum Screen {
    Instance;
    public void up() {System.out.println(" Screen up ");}
    public void down() {System.out.println(" Screen down ");}
}
```

(5)Stereo

```java
public enum Stereo {
    Instance;
    public void on() {System.out.println(" Stereo on ");}
    public void off() {System.out.println(" Screen off ");}
    public void up() {System.out.println(" Screen up.. ");}
}
```

(6)TheaterLight

```java
public enum TheaterLight {
    Instance;
    public void on() {System.out.println(" TheaterLight on ");}
    public void off() {System.out.println(" TheaterLight off ");}
    public void dim() {System.out.println(" TheaterLight dim.. ");}
    public void bright() {System.out.println(" TheaterLight bright.. ");}
}
```

2.外观类，即给调用者提供一个统一的接口方便调用

```java
public class HomeTheaterFacade {
    //定义各个子系统对象
    private TheaterLight theaterLight;
    private Popcorn popcorn;
    private Stereo stereo;
    private Projector projector;
    private Screen screen;
    private DVDPlayer dVDPlayer;
    public HomeTheaterFacade(){
        super();
        this.theaterLight = TheaterLight.Instance;
        this.popcorn = Popcorn.Instance;
        this.stereo = Stereo.Instance;
        this.projector = Projector.Instance;
        this.screen = Screen.Instance;
        this.dVDPlayer = DVDPlayer.Instance;
    }
    //操作分成 4 步
    public void ready() {
        popcorn.on();
        popcorn.pop();
        screen.down();
        projector.on();
        stereo.on();
        dVDPlayer.on();
        theaterLight.dim();
    }
    public void play() {
        dVDPlayer.play();
    }
    public void pause() {
        dVDPlayer.pause();
    }
    public void end() {
        popcorn.off();
        theaterLight.bright();
        screen.up();
        projector.off();
        stereo.off();
        dVDPlayer.off();
    }
}
```

3.调用端Client类，通过外观类可以方便的统筹整个系统中各个子类的关系和调用顺序

```java
public class Client {
    public static void main(String[] args) {
        HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();
        homeTheaterFacade.ready();
        homeTheaterFacade.play();
        homeTheaterFacade.end();
    }
}
```



运行结果如下：

![QQ20220211161345.png](https://img.pterclub.com/images/2022/02/11/QQ20220211161345.png)

## 外观模式在MyBatis框架的应用

MyBatis中的Configuration去创建MetaObject对象时使用到了外观模式。

### 代码

![QQ20220211161656.png](https://img.pterclub.com/images/2022/02/11/QQ20220211161656.png)

### 类图

![QQ20220211161718.png](https://img.pterclub.com/images/2022/02/11/QQ20220211161718.png)

## 注意事项与细节

1.外观模式对外屏蔽了子系统的细节，因此外观模式**降低**了客户端对子系统使用的**复杂性**。

2.外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展。

3.通过合理的使用外观模式，可以帮我们更好的划分访问的层次

4.当系统需要进行分层设计时，可以考虑使用Facade模式

5.在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性。

5.不能**过多的**或者**不合理**的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，**利于维护为目的**。

# 享元模式

## 问题引出

​	小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：

1. 有客户要求以新闻的形式发布
2. 有客户人要求以博客的形式发布
3. 有客户希望以微信公众号的形式发布

### 传统方案

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303100056.png)



​	但是传统方案有一些问题，分析如下：

1.需要的网站结构**相似度很高**，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费。

2.解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源

3.对于代码来说，由于是一份实例，**维护**和**扩展**都更加容易

​	换言之，可以使用**享元模式**来解决问题。

## 基本介绍

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303100341.png)

## 原理类图

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303100400.png)

说明：

1) FlyWeight 是抽象的**享元角色**, 他是产品的**抽象类**, 同时定义出对象的**外部状态**和**内部状态**(后面介绍) 的接口或实现
2) ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务
3) UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂

## 内部状态和外部状态

​	比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一 点，所以**棋子颜色就是棋子的内部状态**；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以**棋子坐标就是棋子的外部状态**。

1.享元模式提出了两个要求：**细粒度**和**共享对象**。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：**内部状态**和**外部状态。**

2.**内部状态**指对象共享出来的信息，存储在享元对象内部且<u>不会随环境的改变而改变</u>。

3.**外部状态**指对象得以依赖的一个标记，是<u>随环境改变而改变的</u>、<u>不可共享</u>的状态。

举个例子：

​		围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，**那么棋子对象就可以减少到只有两个实例**，这样就很好的解决了对象的开销问题。

## 用享元模式解决网站展示问题

### 原理类图

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/QQ截图20220303095605.jpg)

### 代码部分

1.WebSite

```java
public abstract class WebSite {
	public abstract void use(User user);//抽象方法
}
```

2.ConcreteWebSite

```java
public class ConcreteWebSite extends WebSite {//具体网站
	//共享的部分，内部状态
	private String type = ""; //网站发布的形式(类型)
	//构造器
	public ConcreteWebSite(String type) {this.type = type;}
	@Override
	public void use(User user) {
		System.out.println("网站的发布形式为:" + type + " 在使用中 .. 使用者是" + user.getName());
	}
}
```

3.WebSiteFactory

```java
import java.util.HashMap;
// 网站工厂类，根据需要返回压一个网站
public class WebSiteFactory {
	//集合， 充当池的作用
	private HashMap<String, ConcreteWebSite> pool = new HashMap<>();
	//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回
	public WebSite getWebSiteCategory(String type) {
		if(!pool.containsKey(type)) {
			//就创建一个网站，并放入到池中
			pool.put(type, new ConcreteWebSite(type));
		}
		return (WebSite)pool.get(type);
	}
	//获取网站分类的总数 (池中有多少个网站类型)
	public int getWebSiteCount() {
		return pool.size();
	}
}
```

4.User，用于给网站标记外部状态

```java
package com.atguigu.flyweight;
public class User {
	private String name;
	public User(String name) {
		super();
		this.name = name;
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}	
}
```

5.Client

```java
public class Client {
	public static void main(String[] args) {
		// 创建一个工厂类
		WebSiteFactory factory = new WebSiteFactory();
		// 客户要一个以新闻形式发布的网站
		WebSite webSite1 = factory.getWebSiteCategory("新闻");
		webSite1.use(new User("tom"));
		// 客户要一个以博客形式发布的网站
		WebSite webSite2 = factory.getWebSiteCategory("博客");
		webSite2.use(new User("jack"));
		// 客户要一个以博客形式发布的网站
		WebSite webSite3 = factory.getWebSiteCategory("博客");
		webSite3.use(new User("smith"));
		// 客户要一个以博客形式发布的网站
		WebSite webSite4 = factory.getWebSiteCategory("博客");
		webSite4.use(new User("king"));
		System.out.println("网站的分类共=" + factory.getWebSiteCount());
	}
}
```

运行结果：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303102602.png)

## 注意事项和细节

1.在享元模式这样理解，“享”就表示**共享**，“元”表示**对象**。

2.系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式。

3.用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储。

4.享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率。

5.享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们**使用享元模式需要注意的地方**。

6.使用享元模式时，注意划分<u>内部状态</u>和<u>外部状态</u>，并且需要有一个工厂类加以控制。

7.享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池。

# 代理模式

## 基本概念

1.定义：为一个对象提供一个**替身**，以控制对这个对象的访问。即通过代理对象访问目标对象.

这样做的好处是:可以在目标对象实现的基础上,**增强额外的功能操作**,即扩展目标对象的功能。

2.被代理的对象可以是**远程对象**、**创建开销大的对**象或**需要安全控制的对象**。

3.主要有三种代理模式：

**静态代理**、**动态代理** (JDK代理、接口代理)和 **Cglib代理** (可以在内存动态的创建对象，而不需要实现接口， 它是属于动态代理的范畴) 。

4.示意图：用户（客户端）通过代理才能接触到目标对象。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303194337.png)

## 静态代理

​		静态代理在使用时,需要**定义接口**或者**父类,**被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。

### 代码

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303194531.png)

示意图如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303195439.png)

1.ITeacherDao.java

```java
public interface ITeacherDao {
	void teach(); // 授课的方法
}
```

2.TeacherDao.java

```java
public class TeacherDao implements ITeacherDao {
	@Override
	public void teach() {System.out.println(" 老师授课中  。。。。。");}
}
```

3.TeacherDaoProxy.java

```java
//代理对象,静态代理
public class TeacherDaoProxy implements ITeacherDao{
	private ITeacherDao target; // 目标对象，通过接口来聚合
	//构造器
	public TeacherDaoProxy(ITeacherDao target) {this.target = target;}
	@Override
	public void teach() {
		System.out.println("开始代理  完成某些操作。。。。。 ");//方法
		target.teach();
		System.out.println("提交。。。。。");//方法
	}
}
```

4.Client.java

```java
public class Client {
	public static void main(String[] args) {
		//创建目标对象(被代理对象)
		TeacherDao teacherDao = new TeacherDao();
		//创建代理对象, 同时将被代理对象传递给代理对象
		TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);
		//通过代理对象，调用到被代理对象的方法
		//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 
		teacherDaoProxy.teach();
	}
}
```

运行结果：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303195619.png)

### 优缺点

1.优点：在**不修改目标对象**的功能前提下, 能通过代理对象对目标功能扩展。

2.缺点：
（1）因为代理对象需要与目标对象实现一样的接口,所以**会有很多代理类**。

（2）一旦接口增加方法,目标对象与代理对象都要维护。

## 动态代理

### 基本介绍

1.代理对象,不需要实现接口，但是**目标对象要实现接口**，否则不能用动态代理。

2.代理对象的生成，是利用JDK的API，**动态**的**在内存中**构建代理对象，并且通过反射机制返回一个代理对象。

3.动态代理也叫做：JDK代理、接口代理。



JDK的api所在的包是：java.lang.reflect.Proxy，JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是: 

static Object **newProxyInstance**(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )

### 代码

将前面的静态代理改成动态代理模式，示意图如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/QQ截图20220303110540.jpg)

1.ITeacherDao.java

```java
public interface ITeacherDao {//接口
	void teach(); // 授课方法
	void sayHello(String name);
}
```

2.TeacherDao.java

```java
public class TeacherDao implements ITeacherDao {
	@Override
	public void teach() {System.out.println(" 老师授课中.... ");}
	@Override
	public void sayHello(String name) {System.out.println("hello " + name);}
}
```

3.ProxyFactory.java

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class ProxyFactory {
	//维护一个目标对象 , Object
	private Object target;
	//构造器 ， 对target 进行初始化
	public ProxyFactory(Object target) {this.target = target;} 
	//给目标对象 生成一个代理对象
	public Object getProxyInstance() {
		/*  public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)                  
            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定
            //2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型
            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入
		 */
		return Proxy.newProxyInstance(target.getClass().getClassLoader(), 
				target.getClass().getInterfaces(), 
				new InvocationHandler() {
					@Override
					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
						System.out.println("JDK代理开始~~");
						Object returnVal = method.invoke(target, args);//反射机制调用目标对象的方法
						System.out.println("JDK代理提交");
						return returnVal;
					}
				}); 
	}
}
```

4.Client.java

```java
public class Client {
	public static void main(String[] args) {
		//创建目标对象
		ITeacherDao target = new TeacherDao();
		//给目标对象，创建代理对象, 可以转成 ITeacherDao
		ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();
		// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象
		System.out.println("proxyInstance=" + proxyInstance.getClass());
		//通过代理对象，调用目标对象的方法。proxyInstance.teach();
		proxyInstance.sayHello(" tom ");
	}
}
```

运行结果：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303200551.png)

## Cglib

### 基本介绍

1.静态代理和JDK代理模式都要求**目标对象是实现一个接口**,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可**使用目标对象子类**来实现 代理-这就是Cglib代理。

2.Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, <u>有些书也将Cglib代理归属到动态代理</u>。

3.Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接 口.它广泛的被许多AOP的框架使用,例如**Spring AOP，实现方法拦截**。

4.在AOP编程中如何选择代理模式？

​	（1）目标对象**需要实现接口**，用JDK代理。

​	（2）目标对象**不需要实现接口**，用Cglib代理。

5.Cglib包的底层是通过使用**字节码处理框架ASM**来转换字节码并生成新的类。

### 实现步骤

1.需要引入cglib的jar文件

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303200947.png)

2.在内存中动态构建子类，注意代理的类**不能**为final，否则报错：java.lang.IllegalArgumentException: 

3.目标对象的方法如果为final/static,那么就不会被拦截,即<u>不会执行目标对象额外的业务方法</u>。

### 代码

还是将之前的例子改成Cglib的格式，示意图如下

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/QQ截图20220303111851.jpg)

1.TeacherDao.java

```java
public class TeacherDao {
	public String teach() {
		System.out.println(" 老师授课中  ， 我是cglib代理，不需要实现接口 ");
		return "hello";
	}
}
```

2.ProxyFactory.java

```java
import java.lang.reflect.Method;
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
public class ProxyFactory implements MethodInterceptor {
	//维护一个目标对象
	private Object target;
	//构造器，传入一个被代理的对象
	public ProxyFactory(Object target) {this.target = target;}
	//返回一个代理对象:  是 target 对象的代理对象
	public Object getProxyInstance() {
		Enhancer enhancer = new Enhancer();//1. 创建一个工具类
		enhancer.setSuperclass(target.getClass());//2. 设置父类
		enhancer.setCallback(this);//3. 设置回调函数
		return enhancer.create();//4. 创建子类对象，即代理对象
	}
	@Override//重写  intercept 方法，会调用目标对象的方法
	public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {
		System.out.println("Cglib代理模式 ~~ 开始");
		Object returnVal = method.invoke(target, args);
		System.out.println("Cglib代理模式 ~~ 提交");
		return returnVal;
	}
}
```

3.Client.java

```java
public class Client {
	public static void main(String[] args) {
		TeacherDao target = new TeacherDao();//创建目标对象
		//获取到代理对象，并且将目标对象传递给代理对象
		TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();
		//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用
		String res = proxyInstance.teach();
		System.out.println("res=" + res);
	}
}
```

运行结果：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303202053.png)

## 代理模式的几种变体

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303202145.png)

# 模板方法模式

## 基本介绍

1.模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类**公开定义了执行它的方法的<u>模板</u>**。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

2.简单说，模板方法模式 定义一个操作中的算法的**骨架**，而将一些步骤**延迟到子类**中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。

3.这种类型的设计模式属于行为型模式

4.示意图：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303212443.png)

说明：

（1）AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现其它的抽象方法operationr2,3,4。

（2）ConcreteClass 实现**抽象方法**operationr2,3,4, 以完成算法中特点子类的步骤。

## 代码

1.要求：

编写制作豆浆的程序，说明如下: 

（1）制作豆浆的流程 选材--->添加配料--->浸泡--->放到豆浆机打碎

（2）通过添加不同的配料，可以制作出不同口味的豆浆

（3）选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆、花生豆浆...)

2.图解，未包括钩子方法boolean customerWantCondiments()。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303212731.png)

2.钩子方法：

（1）在模板方法模式的父类中，我们可以定义一个方法，**它默认不做任何事**，子类可以**视情况**要不要覆盖它，该方法称为“钩子”。

（2）还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造。

**注意模板方法make()是这个模板方法模式的核心！**

1.SoyaMilk.java

```java
public abstract class SoyaMilk {//抽象类，表示豆浆
	//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.
	final void make() {
		select(); 
		if(customerWantCondiments()) {addCondiments();}
		soak();
		beat();
	}
	//选材料
	void select() {System.out.println("第一步：选择好的新鲜黄豆  ");}
	//添加不同的配料， 抽象方法, 子类具体实现
	abstract void addCondiments();
	//浸泡
	void soak() {System.out.println("第三步， 黄豆和配料开始浸泡， 需要3小时 ");}
	void beat() {System.out.println("第四步：黄豆和配料放到豆浆机去打碎  ");}
	boolean customerWantCondiments() {return true;}//钩子方法，决定是否需要添加配料
}
```

2.红豆豆浆，RedBeanSoyaMilk.java

```java
public class RedBeanSoyaMilk extends SoyaMilk {
	@Override
	void addCondiments() {System.out.println(" 加入上好的红豆 ");}
}
```

3.花生豆浆，PeanutSoyaMilk.java

```java
public class PeanutSoyaMilk extends SoyaMilk {
	@Override
	void addCondiments() {System.out.println(" 加入上好的花生 ");}
}
```

4.纯豆浆，PureSoyaMilk

```java
public class PureSoyaMilk extends SoyaMilk{
	@Override
	void addCondiments() {//空实现
	}
	@Override
	boolean customerWantCondiments() {return false;}
}
```

5.Client.java

```java
public class Client {
	public static void main(String[] args) {
		//制作红豆豆浆
		System.out.println("----制作红豆豆浆----");
		SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();
		redBeanSoyaMilk.make();
		System.out.println("----制作花生豆浆----");
		SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
		peanutSoyaMilk.make();
		System.out.println("----制作纯豆浆----");
		SoyaMilk pureSoyaMilk = new PureSoyaMilk();
		pureSoyaMilk.make();
	}
}
```

运行结果：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303214113.png)

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303214044.png)

## 模板方法模式在Spring中的应用

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303214335.png)

源码的类图：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303214358.png)

## 注意事项和细节

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220303214445.png)
