# Java 内存区域详解

> 参考JavaGuide，[Java 内存区域详解 | JavaGuide](https://javaguide.cn/java/jvm/memory-area.html#简单介绍)，感谢Guide哥！



> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机（由Sun公司开发的Java虚拟机）。
>
> 本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。
>
> 常见面试题 ：
>
> - 介绍下 Java 内存区域（运行时数据区）
> - Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
> - 对象的访问定位的两种方式（句柄和直接指针两种方式）

## 前言

​	对于 Java 程序员来说，在虚拟机自动内存管理机制下，**不再需要**像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 <u>delete/free 操作</u>，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

## 运行时数据区域

​	Java 虚拟机在执行 Java 程序的过程中会把它管理的内存**划分成若干个不同的数据区域**。JDK 1.8 和之前的版本略有不同，下面会介绍到。

**JDK 1.8 之前** ：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091550729.png)

**JDK 1.8 之后** ：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091550164.png)

**线程私有的：**（1）程序计数器（2）虚拟机栈（3）本地方法栈

**线程共享的：**（1）堆（2）方法区（3）直接内存 (非运行时数据区的一部分)

​	Java 虚拟机规范对于运行时数据区域的规定是**相当宽松**的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。

### 程序计数器

​	程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<u>行号指示器</u>。字节码解释器工作时**通过改变这个计数器的值来选取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个**独立的程序计数器**，各线程之间计数器<u>互不影响</u>，<u>独立存储</u>，我们称这类内存区域为“线程私有”的内存。

从上面的介绍中我们知道了程序计数器主要有两个作用：

- 字节码解释器通过**改变程序计数器来依次读取指令**，从而实现代码的<u>流程控制</u>，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

⚠️ 注意 ：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### Java 虚拟机栈

​	与程序计数器一样，Java 虚拟机栈（后文简称栈）也是**线程私有的**，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

​	栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，**其他所有的 Java 方法调用都是通过栈来实现的**（也需要和其他运行时数据区域比如程序计数器配合）。

#### 栈帧

​	方法调用的数据需要**通过栈进行传递**，每一次方法调用都会有一个对应的**栈帧**被<u>压入</u>栈中，每一个方法调用结束后，都会有一个栈帧被<u>弹出</u>。栈由一个个栈帧组成，而每个栈帧中都拥有：**局部变量表**、**操作数栈**、**动态链接**、**方法返回地址**。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091607174.png)

##### 局部变量表

​	**局部变量表** 主要存放了编译期可知的**各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的<u>引用指针</u>，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091608605.png)

##### 操作数栈

​	**操作数栈** 主要作为<u>方法调用的中转站</u>使用，用于存放方法执行过程中产生的**中间计算结果**。另外，**计算过程**中产生的<u>临时变量</u>也会放在操作数栈中。

##### 动态链接

​	**动态链接** 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的<u>变量</u>和<u>方法引用</u>都作为**符号引用**（Symbilic Reference）保存在 Class 文件的<u>常量池</u>里。当一个方法要调用其他方法，需要将常量池中指向方法的<u>符号引用</u>**转化**为其在内存地址中的<u>直接引用</u>。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091612411.png)

​	栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入<u>无限循环</u>的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。

#### 返回方式以及异常

​	Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被<u>弹出</u>。也就是说， **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**除了 `StackOverFlowError` 错误之外，栈还可能会出现`OutOfMemoryError`错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时<u>无法申请到足够的内存空间</u>，则抛出`OutOfMemoryError`异常。

​	简单总结一下程序运行中栈可能会出现两种错误：

- **`StackOverFlowError`：** 若栈的内存大小<u>不允许</u>动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小<u>可以动态扩展</u>， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091617933.png)

### 本地方法栈

​	和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot <u>虚拟机中和 Java 虚拟机栈合二为一</u>。

​	本地方法被执行的时候，在本地方法栈也会创建一个**栈帧**，用于存放该本地方法的**局部变量表**、**操作数栈**、**动态链接**、**出口信息**。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

### 堆

> 在《Java虚拟机规范》中对Java堆的描述是：“所有的**对象实例**以及**数组**都应当在堆上分配”

​	Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程<u>**共享**的一块内存区域</u>，在虚拟机启动时创建。**此内存区域的唯一目的就是存<u>放对象实例</u>，几乎所有的对象实例以及数组都在这里分配内存。**

------

**连续性：**

​	根据《Java虚拟机规范》的规定，Java堆<u>可以处于物理上不连续的内存空间中</u>，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于**大对象**（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

**可拓展性：**

​	Java堆既可以被实现成固定大小的，也可以是可扩展的，不过**当前主流的Java虚拟机都是按照可扩展来实现的**（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。











> ​	Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

#### 分代策略

​	Java 堆是**垃圾收集器管理的主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用<u>分代垃圾收集算法</u>，所以 Java 堆还可以细分为：**新生代**和**老年代**；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是**更好地回收内存**，或者更快地分配内存。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091621005.png)

​	**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是<u>直接内存</u>** （我会在方法区这部分内容详细介绍到）。

​	大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。



> **🐛 修正（参见：[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）** ：“Hotspot 遍历所有对象时，按照年龄**从小到大**对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。
>
> **动态年龄计算的代码如下**
>
> ```c
> uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
> 	//survivor_capacity是survivor空间的大小
> size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);
> size_t total = 0;
> uint age = 1;
> while (age < table_size) {
> total += sizes[age];//sizes数组是每个年龄段对象大小
> if (total > desired_survivor_size) break;
> age++;
> }
> uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;
> 	...
> }
> ```

堆这里最容易出现的就是 `OutOfMemoryError` 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`** ： 当 JVM <u>花太多时间执行垃圾回收</u>并且只能<u>回收很少的堆空间</u>时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, <u>堆内存中的空间不足以存放新创建的对象</u>, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值，详见：[Default Java 8 max heap size](https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size)

3. ...

#### 字符串常量池

​	**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

```java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```

​	HotSpot 虚拟机中字符串常量池的实现是 `src/hotspot/share/classfile/stringTable.cpp` ,`StringTable` 本质上就是一个`HashSet<String>` ,容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置）。**`StringTable` 中保存的是字符串对象的<u>引用</u>，字符串对象的引用指向堆中的字符串对象。**

​	JDK1.7 之前，字符串常量池存放在永久代（方法区的一种实现）。JDK1.7 字符串常量池和静态变量从永久代移动了 Java **堆**中。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091637423.png)

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091638662.png)

**JDK 1.7 为什么要将字符串常量池移动到堆中？**

​	主要是因为**永久代**（方法区实现）的 **GC 回收效率太低**，只有在整堆收集 (Full GC)的时候才会被执行 GC。**Java 程序中通常会有<u>大量的</u>被创建的字符串等待回收**，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

> 相关问题：[JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎](https://www.zhihu.com/question/57109429/answer/151717241)，
>
> ​	回答：如果您说的确实是runtime constant pool（而不是interned string pool / StringTable之类的其他东西）的话，其中的引用类型常量（例如CONSTANT_String、CONSTANT_Class、CONSTANT_MethodHandle、CONSTANT_MethodType之类）都存的是**引用**，实际的对象还是存在Java heap上的。



### 方法区

​	方法区属于是 JVM 运行时数据区域的一块**逻辑区域**，是各个线程共享的内存区域。

​	《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，<u>方法区到底要如何实现那就是虚拟机自己要考虑的事情了</u>。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区<u>会存储</u>已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

​	**方法区和永久代以及元空间是什么关系呢？** 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，<u>接口可以看作是方法区</u>，也就是说永久代以及元空间是 <u>HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</u>。并且，**<u>永久代</u>是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了<u>元空间</u>**。

​	相对而言，垃圾收集行为在这个区域的确是比较少出现的，但<u>并非数据进入了方法区就如永久代的名字一样“永久”存在了</u>。这区域的内存回收目标主要是针对**常量池的回收**和对**类型的卸载**，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是**这部分区域的回收有时又确实是必要的**。





![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091625202.png)

​	**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

​	下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209091626259.png)

​	1、整个永久代有一个 JVM 本身设置的<u>固定大小上限</u>，**无法进行调整**，而元空间使用的是<u>直接内存</u>，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的**几率会更小**。

> 当元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

​	你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，<u>这意味着它只受系统内存的限制</u>。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

​	2、元空间里面存放的是**类的元数据**，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的<u>实际可用空间</u>来控制，这样能加载的类就更多了。

​	3、在 JDK8，合并 HotSpot 和 JRockit（BEA公司开发的JVM） 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

**方法区常用参数有哪些？**

​	JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

​	相对而言，垃圾收集行为在这个区域是**比较少**出现的，但**并非数据进入方法区后就“永久存在”了**。

​	JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

​	与永久代很大的不同就是，**如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存**。

#### 运行时常量池

​	Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种**字面量**（Literal）和**符号引用**（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。

​	字面量是**源代码中的固定值的表示法**，即通过<u>字面我们就能知道其值的含义</u>。字面量包括**整数**、**浮点数**和**字符串字面量**，<u>符号引用</u>包括**类符号引用**、**字段符号引用**、**方法符号引用**和**接口方法符号引用**。常量池表会在类加载后存放到**方法区**的运行时常量池中。运行时常量池的功能类似于<u>传统编程语言的符号表</u>，尽管它包含了比典型符号表更广泛的数据。

​	既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。



​	最后再来分享一段周志明老师在[《深入理解 Java 虚拟机（第 3 版）》样例代码&勘误](https://github.com/fenixsoft/jvm_book)，Github 仓库的 [issue#112](https://github.com/fenixsoft/jvm_book/issues/112)中说过的话：

> ​	**运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是<u>公共且抽象</u>的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。**

### 直接内存

​	直接内存并<u>不是虚拟机运行时数据区的一部分</u>，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

​	JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

​	本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## HotSpot 虚拟机对象探秘

​	通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中<u>对象分配</u>、<u>布局</u>和<u>访问</u>的全过程。

### 对象的创建

Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。

#### Step1:类加载检查

​	虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数**是否能在常量池中定位到这个类的符号引用**，并且检查这个符号引用代表的类是否已被<u>加载过</u>、<u>解析</u>和<u>初始化过</u>。如果没有，那必须先执行相应的**类加载过程**。

####  Step2:分配内存

​	在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在<u>类加载完成后便可确定</u>，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的<u>垃圾收集器是否带有压缩整理功能</u>决定**。

##### **内存分配的两种方式**：指针碰撞和空闲列表

- 指针碰撞 ：
  - 适用场合 ：堆内存**规整**（即没有内存碎片）的情况下。
  - 原理 ：用过的内存全部**整合**到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表 ：
  - 适用场合 ： 堆内存**不规整**的情况下。
  - 原理 ：虚拟机会<u>维护一个列表</u>，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿**足够大**的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

​	选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"**标记-清除**"，还是**"标记-整理**"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

##### 	保证创建对象时线程安全的方式：CAS+失败重试和TLAB

​	在创建对象的时候有一个很重要的问题，就是<u>线程安全</u>，因为在实际开发过程中，创建对象是**很频繁**的事情，作为虚拟机来说，必须要**保证线程是安全的**，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是<u>乐观锁</u>的一种实现方式。所谓乐观锁就是，每次不加锁而是<u>假设没有冲突而去完成某项操作</u>，如果因为冲突失败就**重试**，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，**首先在 TLAB 分配**，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### Step3:初始化零值

​	内存分配完成后，虚拟机需要将分配到的<u>内存空间</u>都**初始化为零值**（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中**可以不赋初始值**就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### Step4:设置对象头

​	初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是<u>哪个类的实例</u>、如何才能找到<u>类的元数据信息</u>、<u>对象的哈希码</u>、<u>对象的 GC 分代年龄</u>等信息。 **这些信息存放在<u>对象头</u>中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁（？）等，对象头会有不同的设置方式。

#### Step5:执行 init 方法

​	在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着**执行 `<init>` 方法**，把对象**按照程序员的意愿进行初始化**，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

​	在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

​	**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，<u>虚拟机通过这个指针来确定这个对象是哪个类的实例</u>。

​	**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的<u>字段内容</u>。这部分的存储顺序会 受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，**相同宽度的字段总是被分配到一起存放**，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。

​	**对齐填充部分<u>不是必然存在的</u>，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 对象的访问定位

​	建立对象就是为了使用对象，我们的 Java 程序通过**栈**上的 **reference 数据**（局部变量表中的）来操作**堆**上的**具体对象**。对象的访问方式由<u>虚拟机实现</u>而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

#### 句柄

​	如果使用句柄的话，那么 **Java 堆中将会划分出一块内存来作为句柄池**，<u>reference</u> 中存储的就是对象的**句柄地址**，而句柄中包含了**对象实例数据**与**对象类型数据各自的具体<u>地址</u>信息**。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092009323.png)

#### 直接指针（HotSpot主要使用的方式）

如果使用直接指针访问，reference 中存储的直接就是对象的地址。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092010323.png)

​	这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是<u>稳定的句柄地址</u>，在对象被移动时**只**会改变句柄中的**实例数据指针**，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

​	HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。

## 参考

- 深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》
- 《自己动手写 Java 虚拟机》
- Chapter 2. The Structure of the Java Virtual Machine：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html
- JVM 栈帧内部结构-动态链接：https://chenxitag.com/archives/368
- Java 中 new String("字面量") 中 "字面量" 是何时进入字符串常量池的? - 木女孩的回答 - 知乎： https://www.zhihu.com/question/55994121/answer/147296098
- JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX 的回答 - 知乎： https://www.zhihu.com/question/57109429/answer/151717241
- http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/

# JVM 垃圾回收详解

> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。
>
> 本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。
>
> 常见面试题 ：
>
> - 如何判断对象是否死亡（两种方法）。
> - 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
> - 如何判断一个常量是废弃常量
> - 如何判断一个类是无用的类
> - 垃圾收集有哪些算法，各自的特点？
> - HotSpot 为什么要分为新生代和老年代？
> - 常见的垃圾回收器有哪些？
> - 介绍一下 CMS,G1 收集器。
> - Minor Gc 和 Full GC 有什么不同呢？

## 前言 

​	当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施**必要的监控和调节**。

## 堆空间的基本结构

​	Java 的自动内存管理主要是针对<u>对象内存的回收</u>和<u>对象内存的分配</u>。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

​	Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

------

1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 

2）强分代假说（Strong Generational Hypothesis）：**熬过越多次垃圾收集过程的对象就越难以消亡**。

​	这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时**只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间**；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用<u>较低的频率</u>来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

​	很容易发现分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：**对象不是孤立的，对象之间会存在跨代引用**。假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但<u>新生代中的对象是完全有可能被老年代所引用的</u>，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再**额外遍历整个老年代中所有对象来确保可达性分析结果的正确性**，反过来也是一样。

3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅**占极少数**。

​	这其实是可根据前两条假说逻辑推理得出的隐含推论：**存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。**举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

​	依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录 每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个<u>全局的数据结构</u>（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代**划分成若干小块**，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数 据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

------

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)（也是方法区的一种实现）

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092021748.png)

​	**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存** 。关于堆空间结构更详细的介绍，可以回过头看看 [Java 内存区域详解](https://javaguide.cn/java/jvm/memory-area.html) 这篇文章。



## 内存分配和回收原则

### 对象优先在 Eden 区分配

​	大多数情况下，对象在**新生代中 Eden 区**分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 **Minor GC**（可以理解为“轻微的垃圾回收”）。下面我们来进行实际测试以下。

测试代码：

```java
public class GCTest {
	public static void main(String[] args) {
		byte[] allocation1, allocation2;
		allocation1 = new byte[30900*1024];
	}
}
```

通过以下方式运行：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092023273.png)

添加的参数：`-XX:+PrintGCDetails`

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092023076.png)

运行结果 ：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092025089.png)

​	从上图我们可以看出 Eden 区内存几乎已经被分配完全（**即使程序什么也不做，新生代也会使用 2000 多 k 内存**）。

​	假如我们再为 `allocation2` 分配内存会出现什么情况呢？

```java
allocation2 = new byte[900*1024];
```

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092026058.png)

​	给 `allocation2` 分配内存的时候 Eden 区内存几乎已经被分配完了

​	当 Eden 区**没有足够空间**进行分配时，虚拟机将发起一次 **Minor GC**。GC 期间虚拟机又发现 `allocation1` 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象**提前转移到老年代**（这里的提前指的是 与age到达阈值后转移相比的）中去，老年代上的空间足够存放 `allocation1`，所以不会出现 Full GC。**执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。**

### 大对象直接进入老年代

​	大对象就是需要大量**连续内存空间**的对象（比如：字符串、数组）。大对象直接进入老年代主要是为了避免为大对象分配内存时由于**分配担保机制**（就是提前转移到老年代尽管age不够的时候）带来的复制而降低效率。在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。

### 长期存活的对象将进入老年代

​	既然虚拟机采用了**分代收集**的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，<u>虚拟机给每个对象一个对象年龄（Age）计数器。</u>大部分情况，对象都会首先在 Eden 区域分配。**如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中**，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。

​	对象在 Survivor 中每熬过一次 **MinorGC**,年龄就增加 1 岁，当它的年龄**增加到一定程度**（默认为 15 岁，**默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.**），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

**动态对象年龄判定**

​	为了能更好地适应不同程序的内存状况，HotSpot虚拟机**并不是永远要求**对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中**相同年龄所有对象大小的总和大于 Survivor空间的一半**，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX： MaxTenuringThreshold中要求的年龄。

​	举个例子，比如Survivor有1024KB，现在有3个对象，o1、o2和o3，o1的age为4，大小128KB，o2和o3的的age都为1，但是大小为300KB，那么这个时候因为o2和o3都是同龄的，并且o2的大小+o3的大小=600KB>512KB（Survivor的一半），这个时候大于等于o2年龄大小的对象都会转移到老年代中。即o1 o2 o3都会转移到老年代中。



### 主要进行 gc 的区域

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092034253.png)

**总结：**

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

### 空间分配担保

​	空间分配担保是为了**确保**在 <u>Minor GC</u> 之前**老年代本身还有容纳新生代所有对象的<u>剩余空间</u>**。

​	《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：

> ​	JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代**最大可用的连续空间**是否大于<u>新生代</u>**所有对象总空间**，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 `-XX:HandlePromotionFailure` 参数的设置值是<u>否允许担保失败</u>(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于**历次晋升到老年代对象的平均大小**，如果大于，将<u>尝试</u>进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 `-XX: HandlePromotionFailure` 设置不允许冒险，那**这时就要改为进行一次 Full GC**。
>
> ​	JDK 6 Update 24 之后的规则变为只要**老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小**，就会进行 Minor GC，否则将进行 Full GC。即无关是否允许担保失败的参数设置。

## 死亡对象判断方法

​	堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要**判断哪些对象已经死亡**（即<u>不能再被任何途径使用的对象</u>）。

### 引用计数法

​	给对象中添加一个引用计数器：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

​	**这个方法实现简单，效率高，但是目前主流的虚拟机中并<u>没有选择</u>这个算法来管理内存，其最主要的原因是它很难解决对象之间<u>相互循环引用</u>的问题。**

​	所谓对象之间的相互引用问题，如下面代码所示：除了对象 `objA` 和 `objB` 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

```java
public class ReferenceCountingGc {
    Object instance = null;
    public static void main(String[] args) {
        ReferenceCountingGc objA = new ReferenceCountingGc();
        ReferenceCountingGc objB = new ReferenceCountingGc();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
    }
}
```

### 可达性分析算法

> 参考[对象的 finalize() 机制_羡羡ˇ的博客-CSDN博客_finalizer撖寡情](https://blog.csdn.net/xx12321q/article/details/124517988?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124517988-blog-119006432.pc_relevant_multi_platform_whitelistv6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124517988-blog-119006432.pc_relevant_multi_platform_whitelistv6&utm_relevant_index=2)。

​	这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下**搜索**，节点所走过的路径称为<u>引用链</u>，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

​	下图中的 `Object 6 ~ Object 10` 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092043538.png)

**哪些对象可以作为 GC Roots 呢？**

- 虚拟机**栈**(栈帧中的局部变量表)中**引用的对象**。
- **本地方法栈**(Native 方法)中引用的对象。
- 方法区中类**静态属性引用的对象**
- 方法区中**常量引用的对象**，譬如字符串常量池（String Table）里的引用
- 所有被**同步锁持有的对象**，例如sychronize(a)，中的a就是同步锁持有的对象。

> 可触及的：从根节点开始，可以到达这个对象。
>
> 可复活的：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。
>
> 不可触及的：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize()只会被调用一次。非死不可
>
>    **以上 3 种状态中，是由于 finalize()方法的存在，进行的区分。只有在<u>对象不可触及时</u>才可以被回收。**



​	可触及的, 意思就是说, 对象此时存在引用链, 是存活的, 可复活的意思是说, 此对象虽然已经被GC标为了垃圾, 但是此时未调用 finalize() 方法, 这个对象是有可能在finalize()中复活的. **不可触及**的就是说, 此时finalize()方法已经被调用过了(没有复活), 这个对象最终的命运已经是**非死不可**了, 只能静等GC去回收它



**对象可以被回收，就代表一定会被回收吗？**

​	判定一个对象 objA 是否可回收，至少要经历**两次标记过程**：

1.如果对象 objA 到 GC Roots **没有引用链，则进行第一次标记**。

2.进行筛选，判断此对象是否有必要执行 finalize()方法

1.  如果对象 objA **没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过**，则虚拟机视为“没有必要执行（finalize方法）”，objA 被判定为<u>不可触及的</u>。此时就是非死不可的了、

2.  如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。          
3.  finalize()方法是对象逃脱死亡的最后机会，稍后 **GC 会对 F-Queue 队列中的对象进行第二次标记**。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被<u>移出“即将回收”集合</u>。如果即使执行了finalize方法后还是没有和任何GCROOTS建立联系，则会被判别为不可触及的。之后，对象会再次出现没有引用存在的情况. 在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize()方法只会被调用一次。



> `Object` 类中的 `finalize` 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 `finalize` 方法会被**逐渐弃用移除**。忘掉它的存在吧！
>
> 参考：
>
> - [JEP 421: Deprecate Finalization for Removal](https://openjdk.java.net/jeps/421)
> - [是时候忘掉 finalize 方法了](https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg)

------

探讨一下finalize方法：在jdk1.8文档中，对于finalize方法的描述如下：

> ​	Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup.
> ​	The general contract of finalize is that it is invoked if and when the Java™ virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded.
> ​	The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition.
> The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates.
> ​	After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded.
> ​	The finalize method is never invoked more than once by a Java virtual machine for any given object.
> ​	Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.
>
> 翻译如下：
>
> ​	当垃圾回收确定不再有对对象的引用时，由垃圾回收器对对象调用。子类重写finalize方法以处置系统资源或执行其他清理。
> ​	finalize的一般约定是，当Java™ 虚拟机已确定不再有任何方法可供尚未死亡的任何线程访问此对象，除非由于某个其他对象或类的终结而采取的操作，该对象或类已准备好终结。finalize方法<u>可以采取任何动作</u>，包括使该对象再次对其他线程可用；**但是，finalize的通常目的是在对象被不可撤销地丢弃之前执行清理操作。**例如，表示输入/输出连接的对象的finalize方法可能会执行显式I/O事务，以在对象被永久丢弃之前中断连接。
> ​	Object类的对象的finalize方法不执行特殊操作；它只是正常返回。对象的子类可以**覆盖此定义**。
> ​	Java编程语言不保证哪个线程将调用任何给定对象的finalize方法。但是，可以保证调用finalize的线程在调用finalize时不会持有任何用户可见的同步锁。如果finalize方法引发未捕获的异常，则该异常将被忽略，该对象的终结将终止。
> ​	在对一个对象调用finalize方法后，不会有进一步的行动，直到Java虚拟机再次确定不再有任何方法可以让这个对象被任何尚未死亡的线程访问，包括其他对象或准备被最终确定的类的可能行动，这时对象可能被丢弃。
> ​	Java虚拟机对任何给定对象调用finalize方法的次数不会超过一次。
> ​	finalize方法引发的任何异常都会导致该对象的终结被暂停，否则将被忽略。



> 下面的分析有参考：[是时候忘掉finalize方法了 (qq.com)](https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg)

​	Java的finalizer的作用与C++析构函数不同。在C++中（在引入类似shared_ptr之类的机制之前），只要你在构造函数中使用new创建了某些内容，就需要在析构函数中调用delete。于是人们就错误地将这种想法带到了Java中，**同时也是Java语言提出初期一种让C/C++程序员更快上手Java语言的一种妥协**，他们认为有必要编写finalize方法来清除对其他对象的引用（其实根本没有这个必要，其实我们很少在使用这个方法了）。 在Java中，垃圾收集器会清理堆中的任何东西，所以根本没必要使用finalize方法来做这件事情。



​	finalize方法的有个问题就是，它允许对象的“**复活**”。当一个对象的finalize方法被调用时，它可以<u>引用this</u>（即将被收集的对象）。这个时候就可以将this这个引用又**挂载回对象图**（object graph）中，从而**逃过了对象收集**。因此，在finalize方法返回后，对象不会被轻易的收集。相反，垃圾回收器**必须重新运行**才能确定对象是否真正无法访问，从而决定是否收集。

```java
/**
 * finalize的时候逃过gc，通过调用finalize的时候挂载回去，使得第一次finalize回收时复活
 */
public class Resurrection
{
    public static Resurrection obj;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("Resurrection finalize called !!!");
        obj = this;//在finalize方法中复活对象，因为类中的静态变量存在方法区中，并且作为GCRoots，那么GCRoots可以指向这个this对象的话，说明就
        //仍然还有引用链，则不会被GC
    }

    @Override
    public String toString() {
        return "I am Resurrection";
    }

    public static void main(String[] args) throws InterruptedException {
        obj = new Resurrection();
        obj = null; //将obj设为null
        System.gc();//垃圾回收

        Thread.sleep(1000);//
        if(obj == null) {
            System.out.println("obj is null");
        } else {
            System.out.println("obj is alive");//因为finalize的时候又挂载回去了，所以不会回收，还是alive的情况
        }

        System.out.println("第2次调用gc后");
        obj = null;//由于obj被复活，此处再次将obj设为null
        System.gc();//再次gc
        Thread.sleep(1000);
        if(obj == null) {
            //对象的finalize方法仅仅会被调用一次，所以可以预见再次设置obj为null后，obj会被垃圾回收，该语句会被调用
            System.out.println("obj is null");
        } else {
            System.out.println("obj is alive");
        }
    }
}
```

​	所以完全可以忘记这个方法，需要关闭资源的时候用try-with-resources反而会做的更好一些。

> JEP( *JDK Enhancement Proposals*)421中指出：
>
> 不幸的是，finalize有几个关键的基本缺陷。
>
> 1.不可预测的延迟--从一个对象变得不可访问到调用它的finlizer之间可能会有一段<u>任意长的时间</u>。事实上，GC并不能保证任何finalizer都会被调用。
>
> 2.不受约束的行为--终结者代码可以采取任何行动。特别是，它可以保存对被最终化的对象的引用，从而**复活该对象**并使其再次可达。
>
> 3.始终启用 - finlization没有明确的**注册机制**。一个有终结器的类<u>可以为该类的每个实例启用finliazation</u>，无论是否需要。**一个对象的finalize操作不能被取消，即使它对该对象不再需要**。
>
> 4.未指定的线程 - finalization在未指定的线程上以任意的顺序运行。**线程和顺序**都不能被控制。



### 引用类型总结

​	无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，**判定对象的存活都与“引用”有关**。JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

​	JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为**强引用**、**软引用**、**弱引用**、**虚引用**四种（引用强度逐渐减弱）

#### **1．强引用（StrongReference）**

​	以前我们使用的**大部分引用**实际上都是强引用，这是使用**最普遍的引用**。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器<u>绝不会回收</u>它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

#### **2．软引用（SoftReference）**

​	如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果<u>内存空间足够</u>，垃圾回收器就<u>不会回收它</u>，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。**软引用可用来实现内存敏感的高速缓存**。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

#### **3．弱引用（WeakReference）**

​	如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：**只具有弱引用的对象拥有更短暂的生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了**只具有弱引用**的对象，**不管当前内存空间足够与否**，<u>都会回收它的内存</u>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

​	弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### **4．虚引用（PhantomReference）**

​	"虚引用"顾名思义，就是<u>形同虚设</u>，与其他几种引用都不同，**虚引用并不会决定对象的生命周期**。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

​	**虚引用主要用来<u>跟踪对象被垃圾回收的活动</u>**。

​	**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）<u>联合使用</u>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存<u>之前</u>，把这个虚引用**加入到**与之关联的**引用队列**中。**程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。**程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

​	特别注意，在程序设计中一般<u>很少使用弱引用与虚引用</u>，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

### 方法区的垃圾回收

​	方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

#### 如何判断一个常量是废弃常量？

​	运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？

> 字符串常量池的演变过程：
>
> 1. **JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代**
> 2. **JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,<u>运行时常量池剩下的东西还在方法区</u>, 也就是 hotspot 中的永久代** 。
> 3. **JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候<u>字符串常量池还在堆, 运行时常量池还在方法区</u>, 只不过方法区的实现从永久代变成了元空间(Metaspace)**

​	假如在字符串常量池中存在字符串 "abc"，如果当前**没有任何 String 对象引用该字符串常量的话**，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

#### 如何判断一个类是无用的类

​	方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

​	判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对**苛刻许多**。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类**所有的实例都已经被回收**，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，**无法在任何地方通过反射访问该类的方法**。

​	虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

​	在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备<u>类型卸载的能力</u>，以保证不会对方法区造成过大的内存压 力。



##  垃圾收集算法

### 标记-清除算法

​	该算法分为“标记”和“清除”阶段：首先标记出**所有不需要回收的对象**，在标记完成后**统一回收掉所有没有被标记的对象**。它是<u>最基础的收集算法</u>，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

1. **效率问题**
2. **空间问题（标记清除后会产生大量不连续的碎片）**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092055584.png)

### 标记-复制算法

​	为了解决效率问题，“标记-复制”收集算法出现了。**它可以将内存分为大小相同的两块**，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对**内存区间的一半**进行回收。

​	不过其缺陷也显而易见，这种复制回收算法的代价是将**可用内存缩小为了原来的一半**，空间浪费未免太多了一 点。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092102326.png)

### 标记-整理算法

​	根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤**不是直接对可回收对象回收**，而是让**所有存活的对象向一端移动**，然后直接**清理掉端边界以外的内存**。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092107302.png)

​	如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新 所有引用这些对象的地方将会是一种**极为负重的操作**，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“**Stop The World**“（STW）。

### 分代收集算法

​	当前虚拟机的垃圾收集都采用<u>分代收集算法</u>，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为**新生代**和**老年代**，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

​	**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本（因为绝大部分对象已经死去，只需复制存活的少量对象）就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

​	**延伸面试问题：** HotSpot 为什么要分为新生代和老年代？

根据上面的对分代收集算法的介绍回答。

## HotSpot垃圾回收中的算法细节实现

​	这一part主要描述了HotSpot虚拟机在垃圾回收中的一些算法实现，从可达性分析开始，虚拟机对于这些算法的执行效率有较高的考量。

### 根节点枚举

​	无论是哪种垃圾收集算法，第一步永远是标记，标记出需要清除的对象。HotSpot采用的可达性分析来标记不可达的对象，也就是从GC Roots开始遍历，那么一共有哪些GC Roots呢？即遍历的起点有多少个？这就是根节点枚举要解决的问题。

​	固定可作为GC Roots的节点主要在**全局性的引用**（例如常量或类静态属性）与**执行上下文**（例如 栈帧中的本地变量表）中，在这俩地方逐个遍历太花时间。而且迄今为止，所有收集器在根节点枚举这一步骤时都是必须**暂停用户线程的（STW）**，根节点枚举始终还是必须在一个能<u>保障一致性的快照</u>中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在**不断变化**的情况，若这点不能满足的话，分析结果准确性也就无法保证。

> ​	这里引入**准确式内存管理**的概念。
>
> ​	准确式内存管理是指虚拟机可以知道内存中**某个位置的数据具体是什么类型（是引用类型还是整数）**。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。由于使用了准确式内存管 理，Exact VM可以抛弃掉以前Classic VM基于句柄（Handle）的对象查找方式（原因是垃圾收集后对 象将可能会被移动位置，如果地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数 据是引用类型的前提下，那虚拟机肯定是不敢把内存中所有为123456的值改成654321的，所以要使用句柄来保持引用值的稳定），**这样每次定位对象都少了一次间接查找的开销，显著提升执行性能。**现在绝大部分JVM都是用准确式内存管理的。

​	所以当用户线程停顿下来之后，其实并**不需要一个不漏地检查**完所有执行上下文和全局的引用位置，虚拟机应当是<u>有办法直接得到</u>哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为**OopMap**的数据结构来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来（所以可以**直接拿到哪些是引用类型，并根据偏移量直接拿到值**）

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209201558056.png)

### 安全点和安全区域

​	完成GC Roots枚举之后，必须解决一个问题：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会**需要大量的额外存储空间**，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂代价。

​	实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录 了这些信息，这些位置被称为**安全点**（Safepoint）。有了安全点的设定，也就决定了**用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才 能够暂停**。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过 增大运行时的内存负荷。安全点位置的选取基本上是以“**是否具有让程序长时间执行的特征**”为标准进行选定的，因为每<u>条指令执行的时间都非常短暂</u>，程序不太可能因为指令流长度太长这样的原因而长时间执行，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以**只有具有这些功能（方法调用、循环跳转、异常跳转）的指令才会产生安全点**。

​	对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让**所有线程**（这里其实不包括执行JNI调用的线程）**都跑到最近的安全点**，然后停顿下来。这里有两种方案可供选择：**抢先式中断** （Preemptive Suspension）和**主动式中断**（Voluntary Suspension），抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。<u>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</u>

​	而**主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个<u>标志位</u>，**各个线程执行过程时会**不停地主动去轮询**（为了保证轮询的效率，HotSpot使用内存保护陷阱的方式， 把轮询操作精简至只有**一条汇编指令**的程度）这个标志，**一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起**。轮询标志的地方和安全点是<u>重合</u>的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方（意思就是创建对象和在对分配内存时轮询一下标记，如果标记为真就说明要GC了，这个时候就找个最近的安全点中断挂起），这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象

------

​	安全点机制不能很好地处理**程序不执行**的状况，所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去**中断挂起自己**，虚拟机也显然<u>不可能持续等待线程重新被激活分配处理器时间</u>。对于这种情况，就必须引入安全区域（Safe Region）来解决。

​	安全区域是指能够确保在某一段代码片段之中，**引用关系不会发生变化**，因此，在这个区域中任意地方开始垃圾收集<u>都是安全的</u>。我们也可以把安全区域看作**被扩展拉伸了的安全点**。当用户线程执行到安全区域里面的代码时，首先会**标识自己已经进入了安全区域**，那样当这段时间里虚拟机要发起垃圾收集时就<u>不必去管这些已声明自己在安全区域内的线程了</u>，所以线程在安全区域里sleep了也没有关系。

​	当线程要**离开**安全区域时，它要检查虚拟机是否已经完成了<u>根节点枚举</u>（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

### 卡表

​	为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为**记忆集**（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。记忆集是一种**用于记录从<u>非收集区域</u>指向<u>收集区域</u>的指针集合的抽象数据结构**。在垃圾收集的场景中，收集器只需要通过记忆集判断出**某一块非收集区域是否存在有指向了收集区域的指针**就可以了，并不需要了解这些跨代指针的全部细节。

​	HotSpot采用了卡精度的方式来实现记忆集，“卡精度”所指的是用一种称为“**卡表**”（Card Table）的方式去实现记忆集，其中卡表的形式是一个**字节数组**（之所以使用byte数组而不是bit数组主要是速度上的考量，现代计算机硬件都是<u>最小按字节寻址</u>的）。字节数组CARD_TABLE的每一个元素都对应着**其标识的内存区域中一块特定大小的内存块**（HotSpot中是512字节），这个内存块被称作“卡页”（Card Page）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了 地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209201621682.png)



​	一个卡页的内存中通常包含<u>不止一个对象</u>，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将**对应卡表的数组元素的值标识为1**，称为这个元素**变脏**（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能<u>轻易得出哪些卡页内存块中包含跨代指针</u>，把它们加入GC Roots中一并扫描。

### 写屏障 

​	卡表元素<u>何时变脏</u>——有其他分代区域中对象引用了本区域对象时，其对应的 卡表元素就应该变脏，变脏时间点原则上应该发生在**引用类型字段赋值的那一刻**。<u>如何变脏</u>——在HotSpot虚拟机里是通过**写屏障**（Write Barrier）技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作。

​	在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier），直至G1收集器出现之前，其他收集器都只用到了**写后屏障**。更新卡表状态的简化逻辑:

```C
void oop_field_store(oop* field, oop new_value) { 
    // 引用字段赋值操作 
    *field = new_value; 
    // 写后屏障，在这里完成卡表状态更新 
    post_write_barrier(field, new_value); 
}
```

​	应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销（写后屏障更新卡表导致的）。

#### 伪共享

​	除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，**现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的**，<u>当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响</u>（写回、无效化或者同步）而**导致性能降低**，这就是伪共享问题。

​	为了避免伪共享问题，一种简单的解决方案是**不采用无条件的写屏障**，而是<u>先检查卡表标记</u>，只有当该卡表元素*未被标记过时*才将其标记为变脏

```C
if (CARD_TABLE [this address >> 9] != 0) 
    CARD_TABLE [this address >> 9] = 0;
```

### 并发的可达性分析

​	可达性分析算法理论上要求全过程都基于一个**能保障一致性的快照**中才能够进行分析， 这意味着必须<u>全程冻结用户线程的运行</u>。

​	为什么一定要在能能保障一致性的快照中才能进行可达性分析呢？我们这里引入**三色标记法**来进行说明。

​	把遍历对象图过程中遇到的对象，按照“**是否访问过**”这个条件标记成以下三种颜色：

1. 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，**所有的对象都是白色的**，若在分析结束的阶段，<u>仍然是白色的对象</u>，即代表**不可达**。 
2. 黑色：表示对象**已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过**。黑色的对象代 表已经扫描过，它是**安全存活的**，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。 
3. 灰色：表示对象已经被垃圾收集器**访问过**，但这个对象上**至少存在一个引用还没有被扫描过**。 

​	收集器在对象图上标记颜色，如果同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。一种是把**原本消亡的对象错误标记为存活**， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好（G1的原始快照方法）。另一种是把**原本存活的对象错误标记为已消亡**，这就是非常致命的后果了，程序肯定会因此发生错误。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209201639292.png)

​	Wilson于1994年在理论上证明了，**当且仅当以下两个条件同时满足时**，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色： 

·赋值器**插入**了一条或多条从**黑色对象到白色对象的新引用**； 

·赋值器**删除**了全部从**灰色对象到该白色对象的直接或间接引用**；

​	因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别 产生了两种解决方案：**增量更新**（Incremental Update）和**原始快照**（Snapshot At The Beginning， **SATB**）

​	<u>增量更新</u>（CMS采用的）要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个**新插入的引用记录下来**，等并发扫描结束之后，再将这些记录过的引用关系中的**黑色对象为根，重新扫描一次**。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象 了。

​	<u>原始快照</u>要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次（也就是**不管被删除引用指向的对象最终是否存活，都将其重新标记，让其存活**；若该对象最终存活，则不会漏标（即不应该被清理的对象存活了下来）；若最终不存活，则该对象成为浮动垃圾（应该被清理的对象存活了下来），下次再回收）。这也可以简化理解为，无论引用关系删除与否，**都会按照刚刚开始扫描那一刻的对象图快照来进行搜索**。





## 垃圾收集器

​	**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

​	虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还<u>没有最好的垃圾收集器</u>出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。

​	下面探讨的都是在JDK 7 Update 4 之后（在这个版本中正式提供了商用的G1收集器，此前G1仍处于实验状态）、JDK 11正式发布之前，OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。

​	因为在G1之前，每个收集器都只是Minor GC或者MajorGC，即只关注某一代的垃圾回收，但是JVM的运行时垃圾回收不能只回收某一代的垃圾，所有代的垃圾都要有一个垃圾回收器去负责，所以就会出现**垃圾回收器搭配工作**的情况（比如ParNew只收集年轻代，CMS只收集老年代，它们可以搭配在一起使用），但并不是任意的不同代的垃圾收集器都可以搭配使用，下面就是各个垃圾收集器的搭配工作情况：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209211105971.png)



### Serial 收集器

​	Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个**单线程收集器**了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候**必须暂停其他所有的工作线程**（ **"Stop The World"** ），直到它收集结束。

​	**新生代采用标记-复制算法，老年代（Serial-Old）采用<u>标记-整理</u>算法。**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209211114500.png)

​	虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中**停顿时间在不断缩短**（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

​	但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有<u>线程交互的开销</u>，自然可以获得很高的单线程收集效率（特别是在单核的环境下，更能展现出优势）。事实上，迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于<u>内存资源受限的环境</u>，它是所有收集器里**额外内存消耗**（指为保证垃圾收集能够顺利高效地进行而存储的<u>额外信息</u>）**最小的**；

------



### ParNew 收集器

​	**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用<u>多线程</u>进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。新生代采用标记-复制算法，老年代采用<u>标记-整理</u>（Serial Old）算法。**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209211115265.png)

​	它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

**并行和并发概念补充：**

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于**等待状态**。
- **并发（Concurrent）**：指**用户线程**与**垃圾收集线程**<u>同时执行</u>（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

------



### Parallel Scavenge 收集器（JDK1.8的默认的新生代收集器）

​	Parallel Scavenge 收集器也是使用<u>标记-复制</u>算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

```text
-XX:+UseParallelGC
    使用 Parallel 收集器+ 老年代串行（Serial Old）

-XX:+UseParallelOldGC
    使用 Parallel 收集器+ 老年代并行(Parallel Old)
```

​	**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到<u>最合适的停顿时间或最大吞吐量</u>，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器<u>配合自适应调节策略</u>，把内存管理优化交给虚拟机去完成也是一个不错的选择。自适应调节策略也是Parallel Scavenge收集器**区别**于ParNew收集器的<u>一个重要特性</u>。

​	**新生代采用标记-复制算法，老年代采用标记-整理（Parallel Old）算法。**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092111620.png)

​	**这是 JDK1.8 默认收集器**

使用 `java -XX:+PrintCommandLineFlags -version` 命令查看

```bash
-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC
java version "1.8.0_211"
Java(TM) SE Runtime Environment (build 1.8.0_211-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)
```

​	JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能

------



### Serial Old 收集器

​	**Serial 收集器的老年代版本**，它同样是一个<u>单线程</u>收集器。

它主要有两大用途：

​	一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器<u>搭配使用</u>，

​	另一种用途是**作为 CMS 收集器的后备方案**，在CMS并发收集发生Concurrent Mode Failure时使用。

------



### Parallel Old 收集器（JDK1.8的默认的老年代收集器）

​	**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

### CMS 收集器（第一个真正意义上的并发收集器）

​	**CMS（Concurrent Mark Sweep）收集器是一种以获取<u>最短回收停顿时间</u>为目标的收集器。它非常符合在注重用户体验的应用上使用。**

​	**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机<u>第一款真正意义上的并发收集器</u>，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

​	从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说<u>更加复杂一些</u>。整个过程分为四个步骤：

- **初始标记（会STW）：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** **同时**开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会<u>不断地更新引用域</u>，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会**跟踪记录**这些发生引用更新的地方。
- **重新标记（会STW）：** 重新标记阶段就是为了**修正**并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录（采用增量更新的方式），这个阶段的**停顿时间**一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209092117022.png)

​	从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**虽然CMS不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢。如果应用本来的处理器负载就很高，还要分出一半的运算能 力去执行收集器线程，就可能导致用户程序的执行速度**忽然大幅降低**。

- **无法处理浮动垃圾；**，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶 段，**用户线程是还在继续运行的**，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就**还需要预留足够内存空间提供给用户线程使用**，因此CMS收集器不能像其他收集器那样<u>等待到老年代几乎完全被填满了再进行收集</u>，必须**预留一部分空间供并发收集时的程序运作使用**。在JDK5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，到了JDK6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：**要是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案（即Serial Old的一大用处）：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量<u>空间碎片</u>产生。**将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找 到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。

------



### G1 收集器（里程碑式的成果）

​	**G1 (Garbage-First) 是一款<u>面向服务器</u>的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**它开创了收集器<u>面向局部收集</u>的设计思路和**基于Region的内存布局形式**。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的<u>默认垃圾收集器</u>，而CMS则沦落至被声明为不推荐使用（**Deprecate**）的收集器

​	G1可以面向堆**内存任何部分**（与之前的分代回收有显著不同）来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是**哪块内存中存放的垃圾数量最多**，**回收收益最大**，这就是G1收集器的**Mixed GC**模式。G1开创的**基于Region的堆内存布局**是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：

​	G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个**大小相等**的<u>独立区域（Region）</u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。**收集器能够对扮演不同角色的 Region采用不同的策略去处理**，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能<u>获取很好的收集效果</u>。

​	Region中还有一类特殊的**Humongous区域**，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为<u>老年代的一部分</u>来进行看待。

​	虽然G1仍然保留新生代和老年代的概念，但新生代和老年代**不再是固定**的了，它们都是一系列区域（<u>不需要连续</u>）的**动态集合**。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作 为**单次回收的最小单元**，即每次收集到的内存空间都是Region大小的**整数倍**，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的**垃圾堆积的“价值”大小**，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个**优先级列表**，每次根<u>据用户设定允许的收集停顿时间</u>（使用参数-XX：MaxGCPauseMillis指定，默 认值是200毫秒），**优先处理回收价值收益最大的那些Region**，这也就是“Garbage First”名字的由来。 这种使用Region划分内存空间，以及具有优先级的区域回收方式，**保证了G1收集器在有限的时间内获 取尽可能高的收集效率**（把内存化整为零）。

​	被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，**G1 收集器仍然可以通过并发的方式让 java 程序继续执行**。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从<u>整体</u>来看是**基于“标记-整理”算法**实现的收集器；从<u>局部</u>上来看是基于**“标记-复制”算法**实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个**大优势**，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立**可预测的停顿时间模型**，能让使用者**明确指定在一个长度为 M 毫秒的时间片段**内。

#### 一些问题的解决

1.Region里面存在的跨Region引用对象如何解决？

​	使用**记忆集**避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要<u>复杂很多</u>，它的**每个Region都维护有自己的记忆集**，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种**哈希表**，<u>Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。</u>这 种“**双向**”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来**更复杂**，同时由于Region数量比传统收集器的分代数量明显要多得多，因此**G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担**。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额 外内存来维持收集器工作。

2.并发标记阶段如何保证收集线程与用户线程互不干扰地运行？

​	CMS收集器采用增量更新算法实现，而G1收集器则是通过**原始快照**（SATB）算法来实现的。此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，**程序要继续运行就肯定会持续有新对象被创建**，G1为每一个Region设计了两个名为**TAMS**（Top at Mark Start）的**指针**，<u>把Region中的一部分空间划分出来用于并发回收过程中的新对象分配</u>，**并发回收时新分配的对象地址都必须要在这两个指针位置以上**。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。与CMS中 的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度， G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。

3.怎样建立起可靠的停顿预测模型？

​	G1收集器的停顿预测模型是以**衰减均值**（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录<u>每个Region的回收耗时</u>、<u>每个Region记忆集里的脏卡数量</u>等各个**可测量的步骤花费的成本**，并分析得出*平均值*、*标准偏差*、*置信度*等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但**衰减平均值更准确地代表“最近的”平均状态**。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由 哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。

#### 运作流程

G1 收集器的运作大致分为以下几个步骤：

1.初始标记（Initial Marking）（需要STW）：仅仅只是**标记一下GC Roots能直接关联到的对象**（不进行扫描），并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需**要停顿线程**，但<u>耗时很短</u>，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。

2.并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，**递归扫描整个堆里的对象图，找出要回收的对象**，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要**重新处理SATB（初始快照）记录下的在并发时有引用变动的对象**。

3.最终标记（Final Marking）（需要STW）：对用户线程做另一个**短暂的暂停**，用于处理**并发阶段结束后仍遗留下来**的最后那少量的SATB记录。

4.筛选回收（Live Data Counting and Evacuation）（需要STW）：负责**更新Region的统计数据**，对各个Region的回收价值和成本进行**排序**，根据用户所期望的停顿时间来<u>制定回收计划</u>，可以自由选择**任意多个Region 构成回收集**，然后把决定回收的那一部分Region的**存活对象复制到空的Region中**（标记-复制算法），再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是**必须暂停用户线程**，由多条收集器线程并行完成的。



​	从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的， 换言之，它并非**纯粹地追求低延迟**，官方给它设定的目标是在**延迟可控**的情况下获得**尽可能高的吞吐量，**所以才能担当起“全功能收集器”的重任与期望

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209211234335.png)

​	从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为**追求能够应付应用的内存分配速率** （Allocation Rate），而<u>不追求一次把整个Java堆全部清理干净</u>。这种新的收集器设计思路 从工程实现上看是从G1开始兴起的，所以说G1是收集器技术发展的一个里程碑。

#### 与CMS的比较

1.**空间碎片方面（G1优）**：与CMS 的“标记-清除”算法不同，G1从**整体**来看是基于“<u>标记-整理</u>”算法实现的收集器，但从**局部**（两个Region 之间）上看又是基于“<u>标记-复制</u>”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。

2.**内存占用方面（CMS更小）**：在用户程序运行过程 中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载 （Overload）都要比CMS要高。

​	为什么？虽然G1和CMS都使用卡表来处理跨代指针，但**G1的卡表实现更为复杂**，而且堆中**每个Region**，无论扮演的是新生代还是老年代角色，**都必须有一份卡表**，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；相比起来**CMS的卡表就相当简单， 只有唯一一份**，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝 生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的

3.**执行负载（CMS更小）**：譬如它们都使用到写屏障，CMS用**写后屏障**来更新维护卡表；而G1除了使用**写后屏障**来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索 （SATB）算法，还需要使用**写前屏障**来跟踪并发时的指针变化情况。**由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源**，所以<u>CMS的写屏障实现</u>是直接的**同步操作**，而G1就不得不将其实现为类似于**消息队列**的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再**异步处理**。



​	目前在**小内存应用**（我认为是宿主机内存小的应用）上CMS的表现大概率仍然要会优于G1，而在**大内存应用**（应用运行在大内存上）上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间，



### ZGC 收集器

​	与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用**标记-复制**算法，不过 ZGC 对该算法做了重大改进。在 ZGC 中出现 Stop The World 的情况会更少！

详情可以看 ： [《新一代垃圾回收器 ZGC 的探索与实践》](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)

## 参考

- 深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》

# 类文件结构详解

## 一 概述

​	在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），**它不面向任何特定的处理器，只面向虚拟机**。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

​	Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言**都是运行在 Java 虚拟机之上**。下图展示了不同的语言被不同的编译器编译成`.class`文件最终运行在 Java 虚拟机之上。`.class`文件的二进制格式可以使用 [WinHex](https://www.x-ways.net/winhex/)查看。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121436168.png)

​	可以说`.class`文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。

## 二 Class 文件结构总结

​	根据 Java 虚拟机规范，Class 文件通过 `ClassFile` 定义，有点类似 C 语言的结构体。`ClassFile` 的结构如下：其中u加上数字代表的就是几个字节的意思，比如u4就代表4个字节。

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

​	通过分析 `ClassFile` 的内容，我们便可以知道 class 文件的组成。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121439847.png)

​	下面这张图是通过 IDEA 插件 `jclasslib` 查看的，你可以更直观看到 Class 文件结构。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121439086.png)

​	使用 `jclasslib` 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。下面详细介绍一下 Class 文件结构涉及到的一些组件。

### 2.1 魔数（Magic Number）

```java
    u4             magic; //Class 文件的标志
```

​	每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。

### 2.2 Class 文件版本号（Minor&Major Version）

```java
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
```

​	紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是**次版本号**，第 7 和第 8 位是**主版本号**。每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 `javap -v` 命令来快速查看 Class 文件的版本号信息。

​	**高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件**，但是低版本的 Java 虚拟机**不能执行**高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。（低版本编译器编译的class文件可以在高版本虚拟机中使用，反之则不行）

### 2.3 常量池（Constant Pool）

```java
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
```

​	紧接着主次版本号之后的是常量池，常量池的数量是 `constant_pool_count-1`（**常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”**）。

​	常量池主要存放两大常量：字面量和符号引用。<u>字面量</u>比较接近于 Java 语言层面的的常量概念，如**文本字符串**、**声明为 final 的常量值**等。而<u>符号引用</u>则属于编译原理方面的概念。包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

​	常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：**开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．**

|               类型               | 标志（tag） |          描述          |
| :------------------------------: | :---------: | :--------------------: |
|        CONSTANT_utf8_info        |      1      |   UTF-8 编码的字符串   |
|      CONSTANT_Integer_info       |      3      |       整形字面量       |
|       CONSTANT_Float_info        |      4      |      浮点型字面量      |
|        CONSTANT_Long_info        |     ５      |      长整型字面量      |
|       CONSTANT_Double_info       |     ６      |   双精度浮点型字面量   |
|       CONSTANT_Class_info        |     ７      |   类或接口的符号引用   |
|       CONSTANT_String_info       |     ８      |    字符串类型字面量    |
|      CONSTANT_Fieldref_info      |     ９      |     字段的符号引用     |
|     CONSTANT_Methodref_info      |     10      |   类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info |     11      |  接口中方法的符号引用  |
|    CONSTANT_NameAndType_info     |     12      |  字段或方法的符号引用  |
|     CONSTANT_MothodType_info     |     16      |      标志方法类型      |
|    CONSTANT_MethodHandle_info    |     15      |      表示方法句柄      |
|   CONSTANT_InvokeDynamic_info    |     18      | 表示一个动态方法调用点 |

​	`.class` 文件可以通过`javap -v class类名` 指令来看一下其常量池中的信息(`javap -v class类名-> temp.txt` ：将结果输出到 temp.txt 文件)。

### 2.4 访问标志(Access Flags)

​	在常量池结束之后，紧接着的两个字节代表**访问标志**，这个标志用于识别一些**类**或者**接口层次**的<u>访问信息</u>，包括：这个 Class 是类还是接口，是否为 `public` 或者 `abstract` 类型，如果是类的话是否声明为 `final` 等等。

​	类访问和属性修饰符:

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121451842.png)

我们定义了一个 Employee 类

```java
package top.snailclimb.bean;
public class Employee {
   ...
}
```

通过`javap -v class类名` 指令来看一下类的访问标志。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121452863.png)

### 2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合

```java
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
```

​	类索引用于确定这个类的**全限定名**，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以**父类索引只有一个**，除了 `java.lang.Object` 之外，所有的 java 类都有父类，<u>因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0</u>。

​	接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 `implements` (如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。

### 2.6 字段表集合（Fields）

```java
  	u2             fields_count;//Class 文件的字段的个数
    field_info     fields[fields_count];//一个类会可以有多个字段
```

​	字段表（field info）用于描述接口或类中**声明的变量**。字段包括<u>类级变量</u>以及<u>实例变量</u>，但**不包括**在方法内部声明的**局部变量**。

​	**field info(字段表) 的结构:**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121454398.png)

- **access_flags:** 字段的作用域（`public` ,`private`,`protected`修饰符），是实例变量还是类变量（`static`修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。
- **name_index:** 对常量池的引用，表示的字段的名称；
- **descriptor_index:** 对常量池的引用，表示字段和方法的描述符；
- **attributes_count:** 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；
- **attributes[attributes_count]:** 存放具体属性具体内容。

​	上述这些信息中，各个修饰符都是**布尔值，**要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是**无法固定**的，只能<u>引用</u>常量池中常量来描述。

**字段的 access_flag 的取值:**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121456633.png)

### 2.7 方法表集合（Methods）

```java
    u2             methods_count;//Class 文件的方法的数量
    method_info    methods[methods_count];//一个类可以有个多个方法
```

​	methods_count 表示方法的数量，而 method_info 表示方法表。

​	Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了**访问标志**、**名称索引**、**描述符索引**、**属性表集合**几项。**method_info(方法表的) 结构:**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121500821.png)

**方法表的 access_flag 取值：**

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121500914.png)

​	注意：因为`volatile`修饰符和`transient`修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了`synchronized`、`native`、`abstract`等关键字修饰方法，所以也就多了这些关键字对应的标志。

### 2.8 属性表集合（Attributes）

```java
   u2             attributes_count;//此类的属性表中的属性数
   attribute_info attributes[attributes_count];//属性表集合
```

​	在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，**以用于描述某些场景专有的信息**。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，<u>属性表集合的限制稍微宽松一些</u>，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

## 参考

- [Chapter 4. The class File Format (oracle.com)](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)

- [实例分析Java Class的文件结构 | 酷 壳 - CoolShell](https://coolshell.cn/articles/9229.html)

- [(114条消息) 《Java虚拟机原理图解》 1.2.2、Class文件中的常量池详解（上）_亦山的博客-CSDN博客](https://blog.csdn.net/luanlouis/article/details/39960815)

- 《实战 Java 虚拟机》

# 类加载过程详解

## 类的生命周期

​	一个类的完整生命周期如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121510233.png)

## 类加载过程

​	Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

详见：[jvm规范5.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4)

### 加载

​	类加载过程的第一步，主要完成下面 3 件事情：

1. 通过**全类名**获取定义此类的<u>二进制字节流</u>
2. 将字节流所代表的**静态存储结构**转换为方法区的**运行时数据结构**
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

​	虚拟机规范上面这 3 点并<u>不具体</u>，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 `ZIP` 包中读取（日后出现的 `JAR`、`EAR`、`WAR` 格式的基础）、其他文件生成（典型应用就是 `JSP`）等等。

​	**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型<u>不通过</u>类加载器创建，它由 <u>Java 虚拟机直接创建</u>。**

​	**类加载器**、**双亲委派模型**也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。加载阶段和连接阶段的部分内容是<u>交叉进行的</u>，加载阶段尚未结束，连接阶段可能就已经开始了。

### 连接

#### 验证

​	文件格式验证->元数据验证->字节码验证->符号引用验证

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121513975.png)

#### 准备

​	**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在**方法区**中分配。对于该阶段有以下几点需要注意：

1. 这时候进行内存分配的仅包括**类变量**（ Class Variables ，即<u>静态变量</u>，被 `static` 关键字修饰的变量，只与类相关，因此被称为类变量），而**不包括实例变量**。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的**字符串常量池、静态变量等移动到<u>堆</u>**中，这个时候类变量则会随着 Class 对象一起存放在 **Java 堆**中。相关阅读：[《深入理解Java虚拟机（第3版）》勘误#75](https://github.com/fenixsoft/jvm_book/issues/75)
3. 这里所设置的初始值"通常情况"下是**数据类型默认的零值**（如 0、0L、null、false 等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

**基本数据类型的零值** ： (图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121520700.png)

#### 解析

​	解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。解析动作主要针对**类或接口**、**字段**、**类方法**、**接口方法**、**方法类型**、**方法句柄**和**调用限定符** 7 类符号引用进行。

​	符号引用就**是一组符号来描述目标**，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<u>在程序实际运行时，只有符号引用是不够的</u>，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。<u>Java 虚拟机为每个类都准备了一张**方法表**来存放类中所有的方法。</u>当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

​	综上，解析阶段是**虚拟机将常量池内的<u>符号引用</u>替换为<u>直接引用</u>的过程**，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 初始化

​	初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的<u>最后一步</u>，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

> 说明： `<clinit> ()`方法是编译之后自动生成的。

​	对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的**安全性**。因为 `<clinit> ()` 方法是**带锁线程安全**，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。

​	对于初始化阶段，虚拟机严格规范了**有且只有 5 种情况下，必须对类进行初始化**(只有主动去使用类才会初始化类)：

1.当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条<u>直接码指令</u>时，比如 `new` 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。

- 当 jvm 执行 `new` 指令时会初始化类。即当程序创建一个类的实例对象。
- 当 jvm 执行 `getstatic` 指令时会初始化类。即程序访问类的**静态变量**(不是静态常量，常量会被加载到运行时常量池)。
- 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的<u>静态变量</u>**赋值**。
- 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用**类的静态方法**。

2.使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。

3.初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

4.当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。

5.`MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。

6.**「补充，来自[issue745](https://github.com/Snailclimb/JavaGuide/issues/745)」** 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

## 卸载

> 卸载这部分内容来自 [issue#662](https://github.com/Snailclimb/JavaGuide/issues/662)由 **[guang19](https://github.com/guang19)** 补充完善。

​	卸载类即该类的 Class 对象**被 GC**。卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说**堆不存在该类的实例对象**。
2. 该类没有在其他任何地方**被引用**。
3. 该类的<u>类加载器</u>的实例**已被 GC**。

​	所以，在 JVM 生命周期内，**由 jvm 自带的类加载器加载的类是不会被卸载的**。但是由我们自定义的类加载器加载的类是可能被卸载的。

​	只要想通一点就好了，jdk 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

**参考**

- 《深入理解 Java 虚拟机》
- 《实战 Java 虚拟机》

- [Chapter 5. Loading, Linking, and Initializing (oracle.com)](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html)

# 类加载器详解

​	类加载过程：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

​	一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去**控制字节流的获取方式**（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。所有的类都由类加载器加载，加载的作用就是将 `.class`文件加载到内存。

## 类加载器总结

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：**最顶层**的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：**面向我们用户的加载器**，负责加载当前应用 classpath 下的所有 jar 包和类。

## 双亲委派模型

### 双亲委派模型介绍

​	每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，**首先**会<u>把该请求委派给**父类加载器**的 `loadClass()` 处理</u>，因此所有的请求最终都应该传送到**顶层的启动类加载器** `BootstrapClassLoader` 中。当父类加载器**无法处理**时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202209121547649.png)

每个类加载都有一个父类加载器，我们通过下面的程序来验证。

```java
public class ClassLoaderDemo {
    public static void main(String[] args) {
        System.out.println("ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader());
        System.out.println("The Parent of ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader().getParent());
        System.out.println("The GrandParent of ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader().getParent().getParent());
    }
}
```

Output

```text
ClassLodarDemo's ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2
The Parent of ClassLodarDemo's ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586
The GrandParent of ClassLodarDemo's ClassLoader is null
```

​	`AppClassLoader`的父类加载器为`ExtClassLoader`， `ExtClassLoader`的父类加载器为 null，**null 并不代表`ExtClassLoader`没有父类加载器，而是 `BootstrapClassLoader`** 。

​	其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是<u>“父母这一辈”的人</u>而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“**优先级**”来决定。官方 API 文档对这部分的描述如下:

> The Java platform uses a delegation model for loading classes. **The basic idea is that every class loader has a "parent" class loader.** When loading a class, a class loader first "delegates" the search for the class to its parent class loader before attempting to find the class itself.

### 双亲委派模型实现源码分析

​	双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 `java.lang.ClassLoader` 的 `loadClass()` 中，相关代码如下所示。

```java
private final ClassLoader parent;
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查请求的类是否已经被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {//父加载器不为空，调用父加载器loadClass()方法处理
                        c = parent.loadClass(name, false);
                    } else {//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                   //抛出异常说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    long t1 = System.nanoTime();
                    //自己尝试加载
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

### 双亲委派模型的好处

​	双亲委派模型保证了 Java 程序的<u>稳定运行</u>，可以**避免类的重复加载**（JVM 区分不同类的方式不仅仅根据类名，**相同的类文件被不同的类加载器加载产生的是两个不同的类**），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

### 如果我们不想用双亲委派模型怎么办？

~~为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 `loadClass()` 即可。~~

**🐛 修正（参见：[issue871](https://github.com/Snailclimb/JavaGuide/issues/871) ）** ：自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法

## 自定义类加载器

​	除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`。

## 推荐阅读

- [(114条消息) 深入分析Java ClassLoader原理_xyang0917的博客-CSDN博客_classloader加载原理](https://blog.csdn.net/xyang81/article/details/7292380)
- [老大难的 Java ClassLoader 再不理解就老了 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903729435508750)

- [Java类加载器(ClassLoader) - Gityuan博客 | 袁辉辉的技术博客](http://gityuan.com/2016/01/24/java-classloader/)