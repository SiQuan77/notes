# 前言

> 本笔记参考[SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式，史上最全面的springcloud微服务技术栈课程|黑马程序员Java微服务_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1LQ4y127n4)，感谢黑马！

## 微服务的概念

### 定义

​		维基百科对它的解释：

​		一种软件开发技术- 面向服务的体系结构（SOA）架构样式的一种变体，它提倡将**单一应用程序划分成一组小的服务**，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用<u>轻量级</u>的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据上下文，选择合适的语言、工具对其进行构建。

​		整个微服务的框架可以概括如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310141847.png)

### 特征

微服务有如下架构特征：

1.单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到**单一职责**。

2.自治：团队独立、技术独立、数据独立，独立部署和交付。

3.面向服务：服务提供统一标准的接口，与语言和技术无关。 

4.隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。



​		总结下来就是，一个整体的系统中的各个模块可以做拆分，分成一个一个小的微服务模块每个微服务都是独立存在的，数据库也是按照微服务的划分独立存在的，最重要的是可以独立的部署到生产环境上。请求服务的方式可以通过http的形式进行请求。比如下图所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310142501.png)

### SpringCloud

​		Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，<u>都可以用**Spring Boot**的开发风格做到一键启动和部署</u>。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

​		SpringCloud是目前国内使用最广泛的微服务框架。常用的微服务组件如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310142919.png)

​		我认为，最便捷的部分就是SpringCloud无缝衔接了当前主流方便的web框架Springboot，非常简单地就可以在Springboot的基础上开发SpringCloud微服务。Springboot和SpringCloud的兼容性如下所示：

|      Cloud版本      |         SpringBoot版本         |
| :-----------------: | :----------------------------: |
| 2020.0.x aka llford |             2.4.x              |
|       Hoxton        | 2.2.x,2.3.x(Starting with SR5) |
|      Greenwich      |             2.1.x              |
|      Finchley       |             2.0.x              |
|       Edgware       |             1.5.x              |
|       Dalston       |             1.5.x              |

​		本笔记使用的版本遵循黑马程序员娇嗔，使用的是Hoxton.SR10,SpringBoot版本是2.3.x版本。

## 服务拆分的例子

### 原则

​		既然微服务是将单体架构拆分成一个一个微服务，那么在服务拆分的时候需要遵循一些原则，原则如下：

1.不同微服务，不要重复开发相同业务。（**不要重复造轮子**）

2.微服务数据独立，不要访问其它微服务的数据库。

3.微服务可以将自己的业务**暴露为接口**，供其它微服务调用。

​		比如一个简单的商城案例，可以简单的分为如下的几个模块：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310143941.png)

### 订单、用户例子

​		教程中的例子有两个微服务，分别为订单的微服务和用户的微服务：order-service和user-service。他们对应的数据库是分别两个不同的数据库：cloud-user和cloud-order，结构和数据如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310145043.png)

​		在idea中的结构如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310145516.png)

​		其中两个服务如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310145745.png)

​		开启之后可以通过localhost:8080/order/101来请求订单号id为101的订单的详细信息，localhost:8081/user/1来请求查询用户id为1的用户的详细信息。不过Order的pojo类里还包含了User类，但是Order表里只存了User的id，我们就需要通过跨服务来请求User信息。

​		两个pojo类如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310150718.png)

​		用户查询的有关代码和查询结果如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310151159.png)

#### 跨服务请求

​		要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。如下图所示

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310151442.png)

​		因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。

​		步骤如下所示：

​		1.注册一个RestTemplate的实例到Spring容器（不要忘记了！）

​		2.修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User

​		3.将查询的User填充到Order对象，一起返回

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310151950.png)

# Eureka注册中心

​		在上面的例子中我们在OrderService当中将跨请求的操作写死成localhost:8081端口，若我们的User的微服务有多个实例，且地址会发生改变的话，这么操作就不利于后续的维护拓展。

> order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？
>
> 有多个user-service实例地址，order-service调用时该如何选择？
>
> order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？

这个时候注册中心的作用就体现出来了!

## 基本介绍

​		Eureka是Netflix开发的**服务发现框架**，本身是一个基于**REST**的服务，主要用于定位运行在AWS域中的中间层服务，以达到**负载均衡**和**中间层服务故障转移**的目的。

​		SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。



## 作用

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310152551.png)

​		回答之前的各个问题。

一、order-service如何得知user-service实例地址？

​	获取地址信息的流程如下：

​	1.**服务注册**：user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。

​	2.eureka-server保存服务名称到服务实例地址列表的**映射关系**。

​	3.**服务发现**：order-service根据服务名称，拉取实例地址列表。这个叫**服务发现**或**服务拉取**。

------

二、order-service如何从多个user-service实例中选择具体的实例？

​		order-service从实例列表中利用**负载均衡算法**选中一个实例地址，向该实例地址发起远程调用。

------

三、order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？

​	1.**心跳**：user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态。

​	2.当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除

​	3.order-service拉取服务时，就能将故障实例排除了

>  注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端

## 实践

​		把之前的例子应用到Eureka注册中心上，步骤如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310153126.png)

------

### 搭建Eureka服务端

​	Eureka服务端必须是一个独立的微服务，所以我们现在cloud-demo父工程下创建一个子模块，选择maven工程。

1.在依赖中导入eureka相关依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

2.随后编写启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能，并编写配置文件。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310160840.png)

3.启动服务之后访问该端口得到以下画面：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310161327.png)

可以看到eureka已经显示在其中了

### 注册服务

​		我们将user-service注册到eureka-server中。步骤如下

1.引入依赖：在user-service的pom文件中，引入下面的eureka-client依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

2.配置文件：在user-service中，修改application.yml文件，添加服务名称、eureka地址

```yaml
spring:
  application:
    name: userservice
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

注册完毕之后，再访问eureka界面就可以看到已注册的服务了：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220310162819.png)

------

若想实现一个服务有多个机子呈现的话，可以使用idea里的copy configuration选项，再启动一个userservice。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251425027.png)

设置参数，将server.port改成8082

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251427591.png)

之后就会发现Services工具栏有一栏多的Not Started，其下正是UserApplication在8082端口的实例，启动它即可。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251428541.png)

启动之后再查看eureka界面就可以发现8082端口实例：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251429656.png)

### 发现服务

在eureka注册服务之后，这时请求服务就不用把主机地址写死了，只需要服务名称，就可以从eureka里拉取对应的服务。

将OrderService里跨服务请求改成服务拉取

步骤：

1.修改OrderService的代码，将url和端口改成付服务名

```java
//原来的版本是
//String url="http://127.0.0.1:8081/user/"+order.getUserId();
String url="http://userservice/user/"+order.getUserId();
```

2.在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251434604.png)

这样就可以使用各种负载均衡策略，例如轮询、随机等等。

# Ribbon负载均衡

eureka的负载均衡是通过Ribbon来实现的

## 负载均衡原理

如图所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251440220.png)

## 修改负载均衡的策略

### 原理

IRule决定了负载均衡的策略，如果我们想修改负载均衡的策略，就可以通过IRule入手。

默认的规则实现的是ZoneAvoidanceRule根据zone选择服务列表然后轮询。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251452759.png)

其中各个负载均衡类对应的规则描述如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251452492.png)

### 步骤

方式一：

比如我们想修改order-service请求user-service时的负载均衡的策略，那么我就可以在order-service的OrderAppliction中重新创建一个IRule类，返回一个内置的负载均衡规则类。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251458879.png)

这样设置的话，order-service不管调用什么微服务，都是采用随机负载均衡规则。

------

方式二：

在配置文件方式修改，可以指定请求某个微服务时采用什么规则，如下图所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251500905.png)

## 饥饿加载

顾名思义：饥不择食，上来就先全部加载了。

Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。
而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251507635.png)

# Nacos注册中心

与Eureka类似，但是比Eureka功能更加丰富，在国内受欢迎度较高，Nacos是阿里巴巴的产品，现在是SpringCloud里的组件了。

## nacos安装

去github上下载压缩包之后解压缩，解压路径不要有中文，之后通过在bin目录下cmd，命令输入：startup.cmd -m standalone。

默认登录用户名和密码是：

nacos

nacos

## Nacos服务分级存储模型

​	一个服务可以有多个实例，每个实例部署在不同的机房or地域，就形成了集群。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251558778.png)

​	所以在服务调用的时候，尽可能地选择本地集群的服务，因为跨集群调用延迟比较高。

## 环境隔离-namespace



![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251656286.png)

------

使用方法：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251658896.png)



![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251659344.png)

总结如下：

1.每个namespace都有唯一id

2.服务设置namespace时要写id而不是名称

3.不同namespace下的服务互相不可见

## 使用

### 服务注册到Nacos

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251529196.png)

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251530802.png)

### 配置集群

在服务的实例的application.yml里添加discovery下的cluster-name信息

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251621730.png)

再在nacos里查看

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251624724.png)

如果想三个实例在不同的集群，那么8081和8082再HZ集群上启动起来之后，修改cluster-name为SH，再启动8083即可，也可以通过修改参数来进行。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251629731.png)

可以看到有两个集群，HZ和SH：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251630707.png)

### NacosRule负载均衡

将OrderService配置到HZ集群中，测试**优先调用本地集群**的负载均衡规则。默认的规则没有选择同集群的即HZ的userservice。

------

步骤：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251638917.png)

第2步修改规则是在order-service下的application.yml里进行修改。注意还需要把之前在OrderAppliction.java里写的IRule给注释掉！

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251647179.png)

如果HZ集群的所有实例都停止工作了，nacos就会跨集群调用，这时会弹出警告信息，如下所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251649613.png)

### 根据权重负载均衡

实际部署中会出现这样的场景：
	服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求
	Nacos提供了权重配置来控制访问频率，**权重越大则访问频率越高**。

------

方法:

直接在Nacos控制台设置实例的权重值：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251651385.png)

若权重调整为0，则该实例就不会被访问到。

### 创建非临时实例

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251709046.png)

## 将配置交给nacos来管理

​	有些关键配置我们可以放在nacos中，在nacos里管理和修改后可以实现热更新，可以比较方便快捷。

注意：

​	1.不是所有的配置都适合放到配置中心，维护起来比较麻烦。

​	2.建议将一些关键参数，需要**运行时调整的参数**放到nacos配置中心，一般都是自定义配置。

### 在nacos中添加配置

step1:

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329093327.png)

step2:在弹出的表单中填写配置信息，注意Data ID的写法要规范！

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329093401.png)

点击发布之后就可以看到自己新添加的配置文件了：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329093518.png)

### 统一配置管理

​	微服务启动流程中读取配置的过程如下图所示：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329093628.png)

​	先读取bootstrap.yml再读取本地的配置文件application.yml

------

​	首先需要引入nacos的配置管理客户端依赖，在userservice下的pom.xml里添加如下依赖：

```xml
<!--nacos配置管理依赖-->
<dependency>    
    <groupId>com.alibaba.cloud</groupId>    
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

​	所以我们在resource文件夹下新创建一个bootstrap.yml，并写好相关配置：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329093821.png)

------

​	测试是否读取能读取到nacos的配置文件中的pattern.dateformat，通过Value注解进行测试，在UserController下进行修改：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329094143.png)

​	访问结果如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329094220.png)

### 实现热更新

​	假如我们想在nacos里修改了配置之后，修改的内容可以自动作用于微服务（userservice），那么可以热更新来实现，一共有两种方式实现：

第一种方式：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329094405.png)

------

第二种方式：

​	新创建一个专门用于获取配置的类，然后在这个类上使用@ConfigurationProperties注解

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329094622.png)

​	若有多个前缀，测试如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329095354.png)

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329095428.png)

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329095318.png)

​	若有多个前缀，则在prefix下依次用符号.来表示上下级关系即可。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329095659.png)



​	这两种方式可以混用，比如需要多级访问的时候，可以直接使用@Value注解来实现。

## 多环境配置共享

​	微服务启动时会从nacos读取多个配置文件：

1.[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml

2.[spring.application.name].yaml，例如：userservice.yaml

​	无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此**多环境共享配置**可以写入这个文件

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329134849.png)

## 不同微服务也可以共享配置

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329135207.png)

------

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329135223.png)

## 集群搭建

​	具体看链接内的压缩包：[nacos集群搭建.zip - 蓝奏云 (lanzouj.com)](https://wwz.lanzouj.com/iqXx7028m3ef)

​	上面打不开可以打开这个链接：[Gofile - Share file links quickly and easily](http://gofile.me/6TtvQ/cTEwrwbQS)

​	密码是nacos123

## 总结

### 原理细节

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202203251708335.png)

### 与eureka比较

共同点：

1.都支持服务注册和服务拉取

2.都支持服务提供者心跳方式做健康检测

------

不同点：

1.Nacos支持服务端**主动检测**提供者状态：临时实例采用**心跳模式**，非临时实例采用**主动检测模式**。

2.临时实例心跳不正常会被剔除，非临时实例则不会被剔除

3.Nacos支持服务列表变更的消息**推送模式**，服务列表更新更及时

4.Nacos集群默认采用AP方式（强调数据服务的可用性），当集群中存在非临时实例时，采用CP模式（强调数据的可靠性和一致性）；Eureka采用AP方式。

# http客户端Feign

​	可以通过Feign来实现优雅地通过http调用其他微服务。原先使用的RestTemplate发起远程调用会存在<u>代码可读性差</u>，<u>参数复杂UR难以维护</u>等缺点。

## 使用步骤

step1：

​	引入依赖

```xml
<dependency>    
    <groupId>org.springframework.cloud</groupId>   
    <artifactId>spring-cloud-starter-openfeign</artifactId> 
</dependency>
```

step2：

​	在order-service的启动类添加注解开启Feign的功能，因为是orderservice跨服务调用userservice里的方法，请求user数据。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329144551.png)

step3:(非最佳实践方法)

​	直接编写Feign客户端，创建cn.itcast.order.clients.UserClinet接口

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329145133.png)

（上图的接口名应该为UserClient，打错了...orz）

step4:

​	在OrderService代码里，将RestTemplate代码替换成Feign客户端代码

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/20220329145616.png)

------

Feign内部使用了Ribbon，实现了负载均衡

## 自定义配置

### 可配置项

Feign里有一些配置可以自定义，如下表所示：

| 类型                   | 作用             | 说明                                                         |
| ---------------------- | ---------------- | ------------------------------------------------------------ |
| **feign.Logger.Level** | 修改日志级别     | 包含四种不同的级别：NONE、BASIC、HEADERS、FULL（用的最多的） |
| feign.codec.Decoder    | 响应结果的解析器 | http远程调用的结果做解析，例如解析json字符串为java对象       |
| feign.codec.Encoder    | 请求参数编码     | 将请求参数编码，便于通过http请求发送                         |
| feign. Contract        | 支持的注解格式   | 默认是SpringMVC的注解                                        |
| feign. Retryer         | 失败重试机制     | 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试       |

### 配置方法

方法一：在配置文件中修改

在order-service的application.yml文件中增加如下配置：

```yaml
feign:
  client:
    config:
      default: #这里用default就是全局配置，如果写某个服务名称，则是针对某个微服务的配置
        loggerLevel: FULL #日志级别
```

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204031805261.png)

------

方法二：java代码方式，需要先声明一个Bean

```java
public class FeignClientConfiguration{
    @Bean
    public Logger.Level feignLongLevel(){
        return Logger.Level.BASIC;
    }
}
```

（1）如果是全局配置，则把它放到@EnableFeignClients这个注解中：

```java
@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)
```

(2)如果是局部配置，则把它放到@FeignClient这个注解中：

```java
@FeignClient(value = "userservice", configuration = FeignClientConfiguration.class)
```

BASIC级别的日志显示如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204031920862.png)

## 性能优化

### Feign底层的客户端实现

Feign底层默认使用的是URLConnection，它**不支持连接池**，影响性能与效率。而**Apache HttpClient**和**OKHttp**是支持连接池的。、

### 两个方向

1.日志级别最好使用basic或者none

2.使用连接池来代替默认的URLConnection

（1）引入依赖

```xml
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-httpclient</artifactId>
</dependency>
```

(2)配置application.yml文件

```yaml
feign: #通过配置文件来自定义Feign的配置
  client: # 用于配置Feign的日志的
    config:
      default: #这里用default就是全局配置，如果写某个服务名称，则是针对某个微服务的配置
        loggerLevel: NONE #日志级别
  httpclient: #httpclient的配置
    enabled: true
    max-connections: 200 # 最大连接数
    max-connections-per-route: 50 # 单个路径的最大连接数
```

## 最佳实践

​	最佳实践指的是企业在实际使用过程中总结出来的相对好用的Feign的使用方式。

### 继承方式

​	user-service里的controller中查询用户方法和order-service里的UserClient接口里的方法是一致的。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204031947181.png)

​	所以考虑给消费者的FeignClient和提供者的controller定义统一的父接口作为标准

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204031949663.png)

### 抽取方式

​	将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204031951020.png)



实现步骤：

1.首先创建一个module，命名为feign-api，然后引入feign的starter依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

2.将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032002256.png)

3.在order-service中删去之前的clients,config和pojo包下的User之后引入自己写的feign-api的依赖。

```xml
<dependency>
    <groupId>cn.itcast.demo</groupId>
    <artifactId>feign-api</artifactId>
    <version>1.0</version>
</dependency>
```

4.修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包
5.还需要修改启动类，得让启动类能扫描到UserClinet，这有两种方式

（1）指定FeignClient所在包（批量引入）

```java
@EnableFeignClients(basePackages = "cn.itcast.feign.clients")
```

（2）指定FeignClient字节码（精准引入），可以是个数组，精准导入多个类

```java
@EnableFeignClients(clients = {UserClient.class})
```

# 统一网关Gateway

## 作用

​	我们的微服务在nacos里注册并且发现，用户如果直接能调取微服务的接口的话，存在安全隐患和权限问题，使用一个网关来对用户的请求做处理，用户先访问网关，又网关来处理微服务的调用问题，这样微服务的接口就不会暴露出来，只会在内部可见。

​	总结下来网关有这么几个作用：1.身份认证和权限校验2.服务路由、负载均衡3.请求限流

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032034529.png)

​	在SpringCloud中网关的实现主要包括两种：gateway和zuul，但是Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于**响应式编程**的实现，具备**更好的性能**。

## 使用

### 网关的搭建

1.创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖：

```xml
<!--网关依赖-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<!--nacos服务发现依赖-->
<dependency>    
    <groupId>com.alibaba.cloud</groupId>   
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> 
</dependency>

```

2.随后写好gateway的启动类

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032039224.png)

### 编写路由配置及nacos地址

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032049347.png)

​	在resource文件夹下新建application.yml文件，填写以下配置：

```yaml
server:
  port: 10010 # 网关端口
spring:
  application:
    name: gateway # 服务名称
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos地址
    gateway:
      routes: # 网关路由配置
        - id: user-service # 路由id，自定义，只要唯一即可
          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址
          uri: lb://userservice # 路由的目标地址 lb就是loadbalance(负载均衡)，后面跟服务名称
          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件
            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
        - id: order-service
          uri: lb://orderservice
          predicates:
            - Path=/order/**

```

​	配置完成后启动，访问网关端口10010，然后按照访问路径请求，发现请求的内容一致。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032046777.png)

------

网关通过路由表来想nacos注册中心拉取服务列表，进行负载均衡后发送具体的请求

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032047202.png)

## 断言工厂

​	我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件。

​	例如Path=/user/**   是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.**PathRoute**PredicateFactory类来处理的。像这样的断言工厂在SpringCloudGateway还有十几个。

​	要满足所用断言条件的时候，gateway才会进行相应的跳转。

具体如下：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032051298.png)

具体用法可以参照spring的官方文档：[Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)

比如我们想测试一下After工厂

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032056569.png)



![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032057313.png)

## 路由过滤器

### 工作流程

​	GatewayFilter是网关中提供的一种过滤器，可以对**进入网关**的<u>请求</u>和微服务**返回**的<u>响应</u>做处理：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032100948.png)

### 过滤工厂

​	Spring提供了31个过滤工厂，[Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories)。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032102159.png)

### 使用

​	给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!

​	实现方式：

​			在gateway中修改application.yml文件，给userservice的路由添加过滤器

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032107475.png)

​	随后在UserController中获取请求头并打印：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032108589.png)

​	请求/user/1，可以发现请求到了，不过访问/order/101的话打印出来的就是null

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032112390.png)

### 默认过滤器

​	如果要对所有的路由都生效，则可以将过滤器工厂写到default下

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032124362.png)



![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032123685.png)

### 全局过滤器

​	全局过滤器的作用也是处理**一切**进入网关的<u>请求</u>和微服务<u>响应</u>，与GatewayFilter的作用一样。
​	区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要**自己写代码**实现。
定义方式是实现GlobalFilter接口。

```java
public interface GlobalFilter {
    /**
    *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
    *
    * @param exchange 请求上下文，里面可以获取Request、Response等信息
    * @param chain 用来把请求委托给下一个过滤器 
    * @return {@code Mono<Void>} 返回标示当前过滤器业务结束
    */
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}
```

------

使用：

​	定义全局过滤器，拦截并**判断用户身份**

​	需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：
​	1.参数中是否有authorization，
​	2.authorization参数值是否为admin
如果同时满足则放行，否则拦截



步骤：

在gateway包下创建AuthorizeFilter类，继承GlobalFilter

```java
package cn.itcast.gateway;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Order(-1) //这个值越小，过滤器优先级越高
@Component
public class AuthorizeFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        //1.获取请求参数
        MultiValueMap<String, String> params = exchange.getRequest().getQueryParams();
        //2.获取参数中的authorization参数
        String auth = params.getFirst("authorization");
        //3.判断参数值是否等于admin
        if ("admin".equals(auth)) {
            //4.是、放行
            return chain.filter(exchange);
            //5.否，拦截
        }
        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
        return exchange.getResponse().setComplete();
    }
}
```

​	随后测试一下，发现直接访问并且没有带相应的参数时，会直接拒绝访问

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032149956.png)

​	带上authorization参数之后，就可以正常访问了：

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032150983.png)

## 过滤器执行顺序

​	请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter

​	请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，**排序后**依次执行每个过滤器，因为所有过滤器都可以转换为GatewayFilter，所以可以进行排序操作。

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032154573.png)

​	每一个过滤器都必须指定一个int类型的order值，**order值越小，优先级越高，执行顺序越靠前**。GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定。路由过滤器和defaultFilter的order由Spring指定，**默认是按照声明顺序从1递增**。

​	当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行。
可以参考下面几个类的源码来查看：

```
	org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。
	org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链
```

## 跨域问题解决

跨域，域名不一致就是跨域，主要包括：

1.域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com

2.域名相同，端口不同：localhost:8080和localhost8081

产生的原因：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题

解决方案：CORS

![](https://cdn.jsdelivr.net/gh/SiQuan77/img_bed/202204032201736.png)
